#![feature(prelude_import)]
#![allow(incomplete_features)]
#![feature(
    async_fn_in_trait,
    let_chains,
    allocator_api,
    type_alias_impl_trait,
    return_position_impl_trait_in_trait,
    never_type,
    int_roundings,
    if_let_guard,
    inline_const,
    iter_intersperse,
    iter_collect_into,
    trusted_len,
    slice_group_by
)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;

mod cache {

    use std::{collections::HashMap, io};
    use mini_alloc::{FnvHasher, InternedStr, StrInterner};
    use crate::*;
    mod ast_loader_impl {
        use std::io;
        use crate::*;
        struct CacheLoaderRes {}
        #[automatically_derived]
        impl ::core::default::Default for CacheLoaderRes {
            #[inline]
            fn default() -> CacheLoaderRes {
                CacheLoaderRes {}
            }
        }
        impl<'a, L: Loader> CacheLoader<'a, L> {
            pub async fn update(
                &mut self,
                root: String,
                temp_mem: &mut TempMemBase,
            ) -> io::Result<()> {
                let mut res = CacheLoaderRes::default();
                ::core::panicking::panic("not yet implemented")
            }
        }
    }
    pub mod scope {
        use mini_alloc::InternedStr;
        pub type Repr = u16;
        pub struct ScopeCache {
            inner: crate::CacheVec<InternedStr>,
        }
        #[automatically_derived]
        impl ::core::default::Default for ScopeCache {
            #[inline]
            fn default() -> ScopeCache {
                ScopeCache {
                    inner: ::core::default::Default::default(),
                }
            }
        }
        impl ScopeCache {
            pub fn new() -> Self {
                Self::default()
            }
            pub fn view(&self, range: ScopeRange) -> &ScopeView {
                unsafe { std::mem::transmute(self.inner.view(range.inner)) }
            }
        }
        pub struct ScopeView {
            inner: [InternedStr],
        }
        impl ScopeView {
            pub fn name(&self, sym: Sym) -> InternedStr {
                self.inner[sym.0 as usize]
            }
            pub fn resolve(&self, name: InternedStr) -> Option<Sym> {
                self.inner
                    .iter()
                    .rposition(|&sym| sym == name)
                    .map(|index| Sym::new(index))
            }
            pub fn all(&self) -> &[InternedStr] {
                &self.inner
            }
        }
        pub struct ScopeRange {
            inner: crate::CacheVecRange<InternedStr>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ScopeRange {
            #[inline]
            fn clone(&self) -> ScopeRange {
                let _: ::core::clone::AssertParamIsClone<crate::CacheVecRange<InternedStr>>;
                *self
            }
        }
        #[automatically_de:{hello there}rived]
        impl ::core::marker::Copy for ScopeRange {}
        pub struct Scope {
            pub sym_stack: Vec<InternedStr>,
        }
        #[automatically_derived]
        impl ::core::default::Default for Scope {
            #[inline]
            fn default() -> Scope {
                Scope {
                    sym_stack: ::core::default::Default::default(),
                }
            }
        }
        impl Scope {
            pub fn new() -> Self {
                Self::default()
            }
            pub fn push(&mut self, sym: InternedStr) -> Sym {
                let sym_id = self.sym_stack.len();
                self.sym_stack.push(sym);
                Sym::new(sym_id)
            }
            pub fn resolve(&self, name: InternedStr) -> Option<Sym> {
                self.sym_stack
                    .iter()
                    .rposition(|&sym| sym == name)
                    .map(|index| Sym::new(index))
            }
            pub fn start_frame(&mut self) -> ScopeFrame {
                ScopeFrame {
                    sym_stack_len: self.sym_stack.len(),
                }
            }
            pub fn end_frame(&mut self, frame: ScopeFrame) {
                self.sym_stack.truncate(frame.sym_stack_len);
            }
            pub fn cache(&mut self, cache: &mut ScopeCache) -> ScopeRange {
                let mut push = cache.inner.push();
                push.extend(self.sym_stack.drain(..));
                ScopeRange {
                    inner: push.finish(),
                }
            }
        }
        pub struct Sym(Repr);
        #[automatically_derived]
        impl ::core::fmt::Debug for Sym {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Sym", &&self.0)
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Sym {
            #[inline]
            fn clone(&self) -> Sym {
                let _: ::core::clone::AssertParamIsClone<Repr>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Sym {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Sym {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Sym {
            #[inline]
            fn eq(&self, other: &Sym) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for Sym {}
        #[automatically_derived]
        impl ::core::cmp::Eq for Sym {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<Repr>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Sym {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for Sym {
            #[inline]
            fn partial_cmp(&self, other: &Sym) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for Sym {
            #[inline]
            fn cmp(&self, other: &Sym) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            :{hello there}
        }
        impl Sym {
            pub fn new(index: usize) -> Self {
                Self(index.try_into().expect("exceeded sym count limit"))
            }
            pub fn index(self) -> usize {
                self.0 as usize
            }
        }
        pub struct ScopeFrame {
            sym_stack_len: usize,
        }
    }
    pub mod storage {
        use std::{
            marker::PhantomData,
            mem,
            ops::{Index, IndexMut},
        };
        pub struct CachePool<T> {
            data: Vec<Option<T>>,
            free: Vec<CacheRef<T>>,
        }
        impl<T> Default for CachePool<T> {
            fn default() -> Self {
                Self {
                    data: Vec::new(),
                    free: Vec::new(),
                }
            }
        }
        impl<T> CachePool<T> {
            pub fn new() -> Self {
                Self::default()
            }
            pub fn push(&mut self, value: T) -> CacheRef<T> {
                let index = if let Some(index) = self.free.pop() {
                    index
                } else {
                    let index = self.data.len();
                    self.data.push(None);
                    CacheRef::new(index)
                };
                self.data[index.0 as usize] = Some(value);
                index
            }
            pub fn remove(&mut self, index: CacheRef<T>) -> T {
                let value = self.data[index.0 as usize]
                    .take()
                    .expect("cache entry already removed");
                self.free.push(index);
                value
            }
        }
        impl<T> Index<CacheRef<T>> for CachePool<T> {
            type Output = T;
            fn index(&self, index: CacheRef<T>) -> &Self::Output {
                self.data[index.0 as usize]
                    .as_ref()
                    .expect("accessed removed cache entry")
            }
        }
        impl<T> IndexMut<CacheRef<T>> for CachePool<T> {
            fn index_mut(&mut self, index: CacheRef<T>) -> &mut Self::Output {
                self.data[index.0 as usize]
                    .as_mut()
                    .expect("accessed removed cache entry")
            }
        }
        type Repr = u16;
        type BaseRepr = u32;
        #[repr(transparent)]
        pub struct CacheRef<T>(Repr, PhantomData<T>);
        #[automatically_derived]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for CacheRef<T> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field2_finish(f, "CacheRef", &self.0, &&self.1)
            }
        }
        #[automatically_derived]
        impl<T: ::core::clone::Clone> ::core::clone::Clone for CacheRef<T> {
            #[inline]
            fn clone(&self) -> CacheRef<T> {
                CacheRef(
                    ::core::clone::Clone::clone(&self.0),
                    ::core::clone::Clone::clone(&self.1),
                )
            }
        }
        #[automatically_derived]
        impl<T: ::core::marker::Copy> ::core::marker::Copy for CacheRef<T> {}
        #[automatically_derived]
        impl<T> ::core::marker::StructuralPartialEq for CacheRef<T> {}
        #[automatically_derived]
        impl<T: ::core::cmp::PartialEq> ::core::cmp::PartialEq for CacheRef<T> {
            #[inline]
            fn eq(&self, other: &CacheRef<T>) -> bool {
                self.0 == other.0 && self.1 == other.1
            }
        :{hello there}
        #[automatically_derived]
        impl<T> ::core::marker::StructuralEq for CacheRef<T> {}
        #[automatically_derived]
        impl<T: ::core::cmp::Eq> ::core::cmp::Eq for CacheRef<T> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<Repr>;
                let _: ::core::cmp::AssertParamIsEq<PhantomData<T>>;
            }
        }
        #[automatically_derived]
        impl<T: ::core::hash::Hash> ::core::hash::Hash for CacheRef<T> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state);
                ::core::hash::Hash::hash(&self.1, state)
            }
        }
        #[automatically_derived]
        impl<T: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for CacheRef<T> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &CacheRef<T>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        ::core::cmp::PartialOrd::partial_cmp(&self.1, &other.1)
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<T: ::core::cmp::Ord> ::core::cmp::Ord for CacheRef<T> {
            #[inline]
            fn cmp(&self, other: &CacheRef<T>) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.0, &other.0) {
                    ::core::cmp::Ordering::Equal => ::core::cmp::Ord::cmp(&self.1, &other.1),
                    cmp => cmp,
                }
            }
        }
        impl<T> CacheRef<T> {
            fn new(index: usize) -> Self {
                Self(
                    index.try_into().expect("exceeded cache entiry limit"),
                    PhantomData,
                )
            }
        }
        pub struct CacheSlice<T>(Repr, Repr, PhantomData<T>);
        #[automatically_derived]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for CacheSlice<T> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field3_finish(
                    f,
                    "CacheSlice",
                    &self.0,
                    &self.1,
                    &&self.2,
                )
            }
        }
        #[automatically_derived]
        impl<T: ::core::clone::Clone> ::core::clone::Clone for CacheSlice<T> {
            #[inline]
            fn clone(&self) -> CacheSlice<T> {
                CacheSlice(
                    ::core::clone::Clone::clone(&self.0),
                    ::core::clone::Clone::clone(&self.1),
                    ::core::clone::Clone::clone(&self.2),
                )
            }
        }
        #[automatically_derived]
        impl<T: ::core::marker::Copy> ::core::marker::Copy for CacheSlice<T> {}
        #[automatically_derived]
        impl<T> ::core::marker::StructuralPartialEq for CacheSlice<T> {}
        #[automatically_derived]
        impl<T: ::core::cmp::PartialEq> ::core::cmp::PartialEq for CacheSlice<T> {
            #[inline]
            fn eq(&self, other: &CacheSlice<T>) -> bool {
                self.0 == other.0 && self.1 == other.1 && self.2 == other.2
            }
        }
        #[automatically_derived]
        impl<T> ::core::marker::StructuralEq for CacheSlice<T> {}
        #[automatically_derived]
        impl<T: ::core::cmp::Eq> ::core::cmp::Eq for CacheSlice<T> {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<Repr>;
                let _: ::core::cmp::AssertParamIsEq<PhantomData<T>>;
            }
        }
        #[automatical:{hello there}ly_derived]
        impl<T: ::core::hash::Hash> ::core::hash::Hash for CacheSlice<T> {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state);
                ::core::hash::Hash::hash(&self.1, state);
                ::core::hash::Hash::hash(&self.2, state)
            }
        }
        #[automatically_derived]
        impl<T: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for CacheSlice<T> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &CacheSlice<T>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(&self.1, &other.1) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::cmp::PartialOrd::partial_cmp(&self.2, &other.2)
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<T: ::core::cmp::Ord> ::core::cmp::Ord for CacheSlice<T> {
            #[inline]
            fn cmp(&self, other: &CacheSlice<T>) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.0, &other.0) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.1, &other.1) {
                            ::core::cmp::Ordering::Equal => {
                                ::core::cmp::Ord::cmp(&self.2, &other.2)
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        impl<T> CacheSlice<T> {
            pub fn new(start: usize, end: usize) -> Self {
                Self(
                    start.try_into().expect("exceeded cache entiry limit"),
                    end.try_into().expect("exceeded cache entiry limit"),
                    PhantomData,
                )
            }
        }
        impl<T> Default for CacheSlice<T> {
            fn default() -> Self {
                Self(0, 0, PhantomData)
            }
        }
        pub struct CacheVec<T> {
            data: Vec<T>,
        }
        impl<T> CacheVec<T> {
            pub fn new() -> Self {
                Self { data: Vec::new() }
            }
            pub fn push(&mut self) -> CacheVecPush<T> {
                let start = self.data.len();
                CacheVecPush { data: self, start }
            }
            pub fn view(&self, range: CacheVecRange<T>) -> &CacheVecView<T> {
                let start = BaseRepr::from_ne_bytes(range.base) as usize;
                let end = start + range.len as usize;
                unsafe { mem::transmute(&self.data[start..end]) }
            }
        }
        impl<T> Default for CacheVec<T> {
            fn default() -> Self {
                Self::new()
            }
        }
        pub struct CacheVecPush<'a, T> {
            data: &'a mut CacheVec<T>,
            start: usize,
        }
        impl<'a, T> CacheVecPush<'a, T> {
            pub fn push(&mut self, value: T) -> CacheRef<T> {
                let index = self.data.data.len();
                self.data.data.push(value);
                CacheRef::new(index - self.start)
            }
            pub fn extend(&mut self, values: impl IntoIterator<Item = T>) -> CacheSlice<T> {
                let start = self.data.data.len();
                self.data.data.extend(values);
                let end = self.data.data.len();
                CacheSlice::new(start - self.start, end - self.start)
            }
            pub fn finish(self) -> CacheVecRange<T> {
                let end = self.data.data.len();
                CacheVecRange {
                    base: (self.st:{hello there}art as BaseRepr).to_ne_bytes(),
                    len: (end - self.start) as Repr,
                    _marker: PhantomData,
                }
            }
            pub fn as_slice(&self) -> &[T] {
                &self.data.data[self.start..]
            }
            pub fn as_mut_slice(&mut self) -> &mut [T] {
                &mut self.data.data[self.start..]
            }
        }
        impl<T> Index<CacheRef<T>> for CacheVecPush<'_, T> {
            type Output = T;
            fn index(&self, index: CacheRef<T>) -> &Self::Output {
                &self.data.data[self.start + index.0 as usize]
            }
        }
        impl<T> IndexMut<CacheRef<T>> for CacheVecPush<'_, T> {
            fn index_mut(&mut self, index: CacheRef<T>) -> &mut Self::Output {
                &mut self.data.data[self.start + index.0 as usize]
            }
        }
        impl<T> Index<CacheSlice<T>> for CacheVecPush<'_, T> {
            type Output = [T];
            fn index(&self, index: CacheSlice<T>) -> &Self::Output {
                &self.data.data[self.start + index.0 as usize..self.start + index.1 as usize]
            }
        }
        impl<T> IndexMut<CacheSlice<T>> for CacheVecPush<'_, T> {
            fn index_mut(&mut self, index: CacheSlice<T>) -> &mut Self::Output {
                &mut self.data.data[self.start + index.0 as usize..self.start + index.1 as usize]
            }
        }
        pub struct CacheVecView<T> {
            data: [T],
        }
        impl<T> CacheVecView<T> {
            pub fn as_slice(&self) -> &[T] {
                &self.data
            }
        }
        impl<T> Index<CacheRef<T>> for CacheVecView<T> {
            type Output = T;
            fn index(&self, index: CacheRef<T>) -> &Self::Output {
                &self.data[index.0 as usize]
            }
        }
        impl<T> Index<CacheSlice<T>> for CacheVecView<T> {
            type Output = [T];
            fn index(&self, index: CacheSlice<T>) -> &Self::Output {
                &self.data[index.0 as usize..index.1 as usize]
            }
        }
        pub struct CacheVecRange<T> {
            base: [u8; 4],
            len: Repr,
            _marker: PhantomData<T>,
        }
        #[automatically_derived]
        impl<T: ::core::clone::Clone> ::core::clone::Clone for CacheVecRange<T> {
            #[inline]
            fn clone(&self) -> CacheVecRange<T> {
                CacheVecRange {
                    base: ::core::clone::Clone::clone(&self.base),
                    len: ::core::clone::Clone::clone(&self.len),
                    _marker: ::core::clone::Clone::clone(&self._marker),
                }
            }
        }
        #[automatically_derived]
        impl<T: ::core::marker::Copy> ::core::marker::Copy for CacheVecRange<T> {}
    }
    macro_rules! decl_ast_model {
        ($name : ident, $view_name : ident, $push_name : ident, $range_name :
        ident < $lt : lifetime > { $($field : ident : $ty : ty,) * }) =>
        {
            #[derive(Default)] pub struct $name
            { $($field : CacheVec < $ty >,) * } impl $name
            {
                pub fn push(& mut self) -> $push_name < '_ >
                { $push_name { $($field : self.$field.push(),) * } } pub fn
                view(& self, range : $range_name) -> $view_name < '_ >
                {
                    $view_name { $($field : self.$field.view(range.$field),) * }
                }
            } pub struct $view_name < 'a >
            { $(pub $field : & 'a CacheVecView < $ty >,) * } pub struct
            $push_name < 'a > { $(pub $field : CacheVecPush < 'a, $ty >,) * }
            #[derive(Copy, Clone)] pub struct $range_name
            { $($field : CacheVecRange < $ty >,) * }
        } ;
    }
    pub struct Cache {
        consts: CacheVec<LiteralKindAst>,
        deps: CacheVec<CacheRef<Module>>,
    }
    #[automatically_derived]
    impl ::core::default::Default for Cache {
        #[inline]
        fn default() -> Cache :{hello there}{
            Cache {
                consts: ::core::default::Default::default(),
                deps: ::core::default::Default::default(),
            }
        }
    }
    impl Cache {
        pub fn push(&mut self) -> CachePush<'_> {
            CachePush {
                consts: self.consts.push(),
                deps: self.deps.push(),
            }
        }
        pub fn view(&self, range: CacheRange) -> CacheView<'_> {
            CacheView {
                consts: self.consts.view(range.consts),
                deps: self.deps.view(range.deps),
            }
        }
    }
    pub struct CacheView<'a> {
        pub consts: &'a CacheVecView<LiteralKindAst>,
        pub deps: &'a CacheVecView<CacheRef<Module>>,
    }
    pub struct CachePush<'a> {
        pub consts: CacheVecPush<'a, LiteralKindAst>,
        pub deps: CacheVecPush<'a, CacheRef<Module>>,
    }
    pub struct CacheRange {
        consts: CacheVecRange<LiteralKindAst>,
        deps: CacheVecRange<CacheRef<Module>>,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for CacheRange {}
    #[automatically_derived]
    impl ::core::clone::Clone for CacheRange {
        #[inline]
        fn clone(&self) -> CacheRange {
            let _: ::core::clone::AssertParamIsClone<CacheVecRange<LiteralKindAst>>;
            let _: ::core::clone::AssertParamIsClone<CacheVecRange<CacheRef<Module>>>;
            *self
        }
    }
    pub struct Module {
        pub name: InternedStr,
        pub scope: ScopeRange,
        pub body: CacheRange,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Module {}
    #[automatically_derived]
    impl ::core::clone::Clone for Module {
        #[inline]
        fn clone(&self) -> Module {
            let _: ::core::clone::AssertParamIsClone<InternedStr>;
            let _: ::core::clone::AssertParamIsClone<ScopeRange>;
            let _: ::core::clone::AssertParamIsClone<CacheRange>;
            *self
        }
    }
    pub struct Modules {
        cahce: Cache,
        scope: ScopeCache,
        modules: CachePool<Module>,
        loaded_modules: HashMap<InternedStr, CacheRef<Module>, FnvHasher>,
        files: Files,
    }
    #[automatically_derived]
    impl ::core::default::Default for Modules {
        #[inline]
        fn default() -> Modules {
            Modules {
                cahce: ::core::default::Default::default(),
                scope: ::core::default::Default::default(),
                modules: ::core::default::Default::default(),
                loaded_modules: ::core::default::Default::default(),
                files: ::core::default::Default::default(),
            }
        }
    }
    impl Modules {
        pub fn new() -> Self {
            Self::default()
        }
    }
    pub trait Loader {
        async fn load(
            &mut self,
            files: &mut Files,
            from: FileRef,
            id: &str,
        ) -> Result<FileRef, io::Error>;
        async fn update(&mut self, files: &mut Files, from: FileRef) -> Result<bool, io::Error>;
    }
    pub struct CacheLoader<'a, L: Loader> {
        loader: &'a mut L,
        modules: &'a mut Modules,
        types: &'a Types,
        interner: &'a StrInterner,
        diagnostics: &'a mut Diagnostics:{hello there},
    }
    impl<'a, L: Loader> CacheLoader<'a, L> {
        pub fn new(
            loader: &'a mut L,
            modules: &'a mut Modules,
            types: &'a Types,
            interner: &'a StrInterner,
            diagnostics: &'a mut Diagnostics,
        ) -> Self {
            Self {
                loader,
                modules,
                types,
                interner,
                diagnostics,
            }
        }
    }
}
mod diagnostics {
    use std::{
        fmt::{Display, Write},
        iter,
        ops::Range,
    };
    use crate::{FileRef, Files, Span};
    pub struct Diagnostics {
        counters: [u32; 4],
        output: String,
        temp_buffer: String,
        annotation_temp: Vec<Annotation>,
        footer_temp: Vec<FooterAnnotation>,
        config: DiagnosticConfig,
    }
    #[automatically_derived]
    impl ::core::default::Default for Diagnostics {
        #[inline]
        fn default() -> Diagnostics {
            Diagnostics {
                counters: ::core::default::Default::default(),
                output: ::core::default::Default::default(),
                temp_buffer: ::core::default::Default::default(),
                annotation_temp: ::core::default::Default::default(),
                footer_temp: ::core::default::Default::default(),
                config: ::core::default::Default::default(),
            }
        }
    }
    impl Diagnostics {
        pub fn with_config(config: DiagnosticConfig) -> Self {
            Self {
                config,
                ..Default::default()
            }
        }
        pub fn diagnostic_view(&self) -> &str {
            &self.output
        }
        fn cache_string(&mut self, message: impl Display) -> Range<usize> {
            let start = self.temp_buffer.len();
            self.temp_buffer
                .write_fmt(format_args!("{0}", message))
                .unwrap();
            let end = self.temp_buffer.len();
            start..end
        }
        fn commit_diagnostic(&mut self, files: &Files) {
            for footer in self.footer_temp.drain(..) {
                footer.display_standalone(
                    &mut self.output,
                    &self.temp_buffer,
                    self.config.skip_colors,
                )
            }
            let highest_severty = self.annotation_temp.iter().map(|a| a.severty).max();
            let Some(highest_severty) = highest_severty else { return; };
            self.counters[highest_severty as usize] += 1;
            self.annotation_temp
                .sort_unstable_by_key(Annotation::get_file);
            struct Padder {
                progress: usize,
                tab_width: usize,
            }
            impl Padder {
                fn new(tab_width: usize) -> Self {
                    Self {
                        progress: 0,
                        tab_width,
                    }
                }
                fn pad(&mut self, out: Option<&mut String>, c: char) {
                    match c {
                        '\t' => {
                            let n = self.tab_width - self.progress % self.tab_width;
                            if let Some(out) = out {
                                out.extend(iter::repeat(' ').take(n));
                            }
                            self.progress += n;
                        }
                        _ => :{hello there}{
                            if let Some(out) = out {
                                out.push(c);
                            }
                            self.progress += 1;
                        }
                    }
                }
            }
            fn num_chars(mut n: u16) -> impl Iterator<Item = char> {
                let mut buf = [0; 5];
                let mut i = 0;
                while n > 0 {
                    buf[i] = (n % 10) as u8 + b'0';
                    n /= 10;
                    i += 1;
                }
                buf.into_iter().take(i).rev().map(char::from)
            }
            for group in self
                .annotation_temp
                .group_by_mut(|a, b| a.get_file() == b.get_file())
            {
                group.sort_unstable_by_key(|a| a.span);
                let first = &group[0];
                let file = first.span.file();
                let file = files.get_file(file);
                let lines = file.source().lines().enumerate();
                self.output
                    .write_fmt(format_args!("-> {0}:\n", file.name().display()))
                    .unwrap();
                let line_number_pad = group
                    .last()
                    .unwrap()
                    .span
                    .row()
                    .saturating_add(self.config.view_range)
                    .ilog10()
                    + 1;
                let mut diags = group.iter().peekable();
                let mut last_diag_line = diags.peek().unwrap().span.row() as usize;
                enum Region {
                    Inside,
                    Outside,
                }
                #[automatically_derived]
                impl ::core::clone::Clone for Region {
                    #[inline]
                    fn clone(&self) -> Region {
                        *self
                    }
                }
                #[automatically_derived]
                impl ::core::marker::Copy for Region {}
                let mut region = Region::Outside;
                let view_range = self.config.view_range as usize;
                'b: for (i, line) in lines {
                    fn check_in_range(i: usize, last_diag_line: usize, view_range: usize) -> bool {
                        i >= last_diag_line.saturating_sub(view_range)
                            && i <= last_diag_line.saturating_add(view_range)
                    }
                    let in_range = check_in_range(i, last_diag_line, view_range);
                    match (region, in_range) {
                        (Region::Outside, true) => {
                            region = Region::Inside;
                        }
                        (Region::Inside, false) => 'a: {
                            if let Some(annotation) = diags.peek() {
                                last_diag_line = annotation.span.row() as usize;
                                if check_in_range(i, last_diag_line, view_range) {
                                    match line {
                                        tmp => {
                                            {
                                                ::std::io::_eprint(format_args!(
                                                    "[{0}:{1}] {2} = {3:#?}\n",
                                                    "stac/src/diagnostics.rs", 141u32, "line", &tmp
                                                ));
                                            };
                                            tmp
                                        }
                                    };
                                    break 'a;
                                }
                            }
                            region = Region::Outside;
                            self.output.push_str("...\n");
                            continue 'b;
                        }
                        (Region::Outside, false) => continue,
                        _ => {}
                    }
                    num_chars(i as u16 + 1)
                        .chain(iter::repeat(' '))
                        .take(line_number_pad as usize)
                        .chain(['|', ' '])
                        .collect_into(&mut self.output);
                    let mut padder = Padder::new(self.config.tab_width);
                    for c in line.chars() {
                        padder.pad(Some(&mut self.output), c)
                    }
                    self.output.push('\n'):{hello there};
                    while let Some(annotation) = diags.peek() &&
                            annotation.span.row() as usize == i {
                        last_diag_line = annotation.span.row() as usize;
                        let mut padder = Padder::new(self.config.tab_width);
                        line[..annotation.span.col()].chars().for_each(|c|
                                padder.pad(None, c));
                        iter::repeat(' ').take(padder.progress +
                                            line_number_pad as usize +
                                        "| ".len()).chain(['^',
                                        ' ']).collect_into(&mut self.output);
                        annotation.display_standalone(&mut self.output,
                            &self.temp_buffer, self.config.skip_colors);
                        diags.next();
                    }
                }
            }
            self.annotation_temp.clear();
            self.temp_buffer.clear();
            self.output.push('\n');
        }
    }
    impl Diagnostics {
        pub fn builder<'ctx>(&'ctx mut self, files: &'ctx Files) -> Diagnostic<'ctx> {
            Diagnostic { inner: self, files }
        }
    }
    pub struct DiagnosticConfig {
        pub tab_width: usize,
        pub skip_colors: bool,
        pub view_range: usize,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DiagnosticConfig {
        #[inline]
        fn clone(&self) -> DiagnosticConfig {
            let _: ::core::clone::AssertParamIsClone<usize>;
            let _: ::core::clone::AssertParamIsClone<bool>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for DiagnosticConfig {}
    impl Default for DiagnosticConfig {
        fn default() -> Self {
            Self {
                tab_width: 4,
                skip_colors: true,
                view_range: 1,
            }
        }
    }
    pub struct Diagnostic<'ctx> {
        inner: &'ctx mut Diagnostics,
        files: &'ctx Files,
    }
    impl<'ctx> Diagnostic<'ctx> {
        pub fn footer(self, severty: Severty, message: impl Display) -> Self {
            let message = self.inner.cache_string(message);
            self.inner
                .footer_temp
                .push(FooterAnnotation { severty, message });
            self
        }
        pub fn annotation(self, severty: Severty, span: Span, message: impl Display) -> Self {
            let message = self.inner.cache_string(message);
            self.inner.annotation_temp.push(Annotation {
                severty,
                span,
                message,
            });
            self
        }
        pub fn terminate(self) -> Option<!> {
            None
        }
    }
    impl Drop for Diagnostic<'_> {
        fn drop(&mut self) {
            self.inner.commit_diagnostic(self.files);
        }
    }
    struct FooterAnnotation {
        severty: Severty,
        message: Range<usize>,
    }
    impl FooterAnnotation {
        fn display_standalone(&self, out: &mut String, cache: &str, skip_color: bool) {
            out.push_str(self.severty.as_ansi_color(skip_color));
            out.push_str(self.severty.as_str());
            out.push_str(self.severty.reset_ansi_color(skip_color));
            out.write_fmt(format_args!(": {0}\n", &cache[self.message.clone()]))
                .unwrap();
        }
    }
    struct Annotation {
        severty: Severty,
        span: Span,
        message: Range<usize>,
    }
    impl Annotation :{hello there}{
        fn get_file(&self) -> FileRef {
            self.span.file()
        }
        fn display_standalone(&self, out: &mut String, cahce: &str, skip_color: bool) {
            out.push_str(self.severty.as_ansi_color(skip_color));
            out.write_fmt(format_args!("{0}\n", &cahce[self.message.clone()]))
                .unwrap();
            out.push_str(self.severty.reset_ansi_color(skip_color));
        }
    }
    #[repr(u8)]
    pub enum Severty {
        Error,
        Warning,
        Note,
        Help,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Severty {
        #[inline]
        fn clone(&self) -> Severty {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Severty {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Severty {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Severty::Error => "Error",
                    Severty::Warning => "Warning",
                    Severty::Note => "Note",
                    Severty::Help => "Help",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Severty {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Severty {
        #[inline]
        fn eq(&self, other: &Severty) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Severty {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Severty {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Severty {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Severty {
        #[inline]
        fn partial_cmp(&self, other: &Severty) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Severty {
        #[inline]
        fn cmp(&self, other: &Severty) -> ::core::cmp::Ordering {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag)
        }
    }
    impl Severty {
        fn as_str(self) -> &'static str {
            match self {
                Severty::Error => "error",
                Severty::Warning => "warning",
                Severty::Note => "note",
                Severty::Help => "help",
            }
        }
        fn as_ansi_color(self, skip: bool) -> &'static str {
            if skip {
                return "";
            }
            match self {
                Severty::Error =>:{hello there} "\x1b[31m",
                Severty::Warning => "\x1b[33m",
                Severty::Note => "\x1b[34m",
                Severty::Help => "\x1b[32m",
            }
        }
        fn reset_ansi_color(self, skip: bool) -> &'static str {
            if skip {
                return "";
            }
            "\x1b[0m"
        }
    }
}
mod lexer {
    use std::fmt::Display;
    use crate::{FileRef, Files, Span};
    pub struct Token<'a> {
        pub kind: TokenKind,
        pub source: &'a str,
        pub span: Span,
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for Token<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Token",
                "kind",
                &self.kind,
                "source",
                &self.source,
                "span",
                &&self.span,
            )
        }
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for Token<'a> {
        #[inline]
        fn clone(&self) -> Token<'a> {
            let _: ::core::clone::AssertParamIsClone<TokenKind>;
            let _: ::core::clone::AssertParamIsClone<&'a str>;
            let _: ::core::clone::AssertParamIsClone<Span>;
            *self
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::Copy for Token<'a> {}
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for Token<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for Token<'a> {
        #[inline]
        fn eq(&self, other: &Token<'a>) -> bool {
            self.kind == other.kind && self.source == other.source && self.span == other.span
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralEq for Token<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::Eq for Token<'a> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<TokenKind>;
            let _: ::core::cmp::AssertParamIsEq<&'a str>;
            let _: ::core::cmp::AssertParamIsEq<Span>;
        }
    }
    #[automatically_derived]
    impl<'a> ::core::hash::Hash for Token<'a> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.kind, state);
            ::core::hash::Hash::hash(&self.source, state);
            ::core::hash::Hash::hash(&self.span, state)
        }
    }
    pub struct Extras {
        line: usize,
        last_newline: usize,
    }
    #[automatically_derived]
    impl ::core::default::Default for Extras {
        #[inline]
        fn default() -> Extras {
            Extras {
                line: ::core::default::Default::default(),
                last_newline: ::core::default::Default::default(),
            }
        }
    }
    pub struct Lexer<'a> {
        lexer: logos::Lexer<'a, TokenKind>,
        file: FileRef,
    }
    impl<'a> Lexer<'a> {
        pub fn new(files: &'a Files, file: FileRef) -> Self {
            Self {
                lexer: TokenKind::lexer(files.:{hello there}get_file(file).source()),
                file,
            }
        }
        pub fn next_tok(&mut self) -> Token<'a> {
            let kind = self
                .lexer
                .next()
                .unwrap_or(Ok(TokenKind::Eof))
                .unwrap_or(TokenKind::Err);
            let span = self.lexer.span();
            let source = self.lexer.slice();
            let span = Span::new(
                self.lexer.extras.line,
                span.start - self.lexer.extras.last_newline,
                self.file,
            );
            Token { kind, source, span }
        }
    }
    impl<'a> Iterator for Lexer<'a> {
        type Item = Token<'a>;
        fn next(&mut self) -> Option<Self::Item> {
            Some(self.next_tok())
        }
    }
    macro_rules! define_lexer {
        (subpatterns { $($subpattern : ident = $subpattern_repr : literal) * }
        tokens { $($token : ident = $token_repr : literal) * } regexes
        { $($regex : ident = $regex_repr : literal) * } operators
        { $(($($op_name : ident : $op : literal), *) = $prec : literal,) * }
        other
        {
            $($(#[$attr : meta]) * $other_name : ident = $other_repr :
            literal) *
        }) =>
        {
            #[derive(Default, Debug, Clone, Copy, PartialEq, Eq, Hash, logos
            :: Logos)] #[logos(skip r"([ \t\r]+|//[^\n]*)")]
            #[logos(extras = Extras)]
            $(#[logos(subpattern $subpattern = $subpattern_repr)]) * pub enum
            TokenKind
            {
                $(#[token($token_repr)] $token,) *
                $(#[regex($regex_repr)] $regex,) *
                $($(#[token($op, | _ | OpCode :: $op_name)]) *) * Op(OpCode),
                $($(#[$attr]) * $other_name,) *
            } impl TokenKind
            {
                pub const TOKEN_COUNT : usize =
                [$($token_repr,) * $($regex_repr,) *].len() ; pub const ALL :
                & [Self] = &
                [$(Self :: $token,) * $(Self :: $regex,) *
                $($(Self :: Op(OpCode :: $op_name),) *) *
                $(Self :: $other_name,) *] ; pub fn name(self) -> & 'static
                str
                {
                    match self
                    {
                        $(Self :: $token => $token_repr,) *
                        $(Self :: $regex => stringify! ($regex),) * Self :: Op(o) =>
                        o.name(), $(Self :: $other_name => $other_repr,) *
                    }
                }
            } #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)] pub enum
            OpCode { $($($op_name,) *) * } impl OpCode
            {
                pub fn name(self) -> & 'static str
                { match self { $($(Self :: $op_name => $op,) *) * } } pub fn
                prec(self) -> u8
                { match self { $($(Self :: $op_name) | * => $prec,) * } }
            }
        } ; (@ token_repr $token : ident = $token_repr : literal) =>
        { $token_repr } ; (@ token_repr $token : ident) =>
        { stringify! ($token) } ;
    }
    fn handle_newlien(lex: &mut logos::Lexer<TokenKind>) -> logos::Skip {
        lex.extras.line += 1;
        lex.extras.last_newline = lex.span().end;
        logos::Skip
    }
    #[logos(skip r"([ \t\r]+|//[^\n]*)")]
    #[logos(extras = Extras)]
    #[logos(subpattern ident_start = r"[a-zA-Z_]")]
    #[logos(subpattern ident_content = r"[a-zA-Z0-9_]")]
    pub enum TokenKind {
        #[token("if")]
        If,

        #[token("else")]
        Else,

        #[token("loop")]
        Loop,

        #[token("ret")]
        Ret,

        #[token("for")]
        For,
:{hello there}
        #[token("in")]
        In,

        #[token("unknown")]
        Unknown,

        #[token("true")]
        True,

        #[token("false")]
        False,

        #[token(".")]
        Dot,

        #[token("..")]
        DoubleDot,

        #[token(",")]
        Comma,

        #[token(";")]
        Semi,

        #[token(":")]
        Colon,

        #[token("|{")]
        Enum,

        #[token("*{")]
        Struct,

        #[token("{")]
        LBrace,

        #[token("}")]
        RBrace,

        #[token("[")]
        LBracket,

        #[token("]")]
        RBracket,

        #[token("*(")]
        Tuple,

        #[token("(")]
        LParen,

        #[token(")")]
        RParen,

        #[regex(r"(?&ident_start)(?&ident_content)*")]
        Ident,

        #[regex(r":\{[^\n\r\t}]*\}")]
        Import,

        #[regex(r#""([^"]|\\")*""#)]
        Str,

        #[regex(r"[0-9]+")]
        Int,

        #[token("*", | _ | OpCode :: Mul)]
        #[token("/", | _ | OpCode :: Div)]
        #[token("%", | _ | OpCode :: Mod)]
        #[token("+", | _ | OpCode :: Add)]
        #[token("-", | _ | OpCode :: Sub)]
        #[token("<<", | _ | OpCode :: Shl)]
        #[token(">>", | _ | OpCode :: Shr)]
        #[token("&", | _ | OpCode :: BitAnd)]
        #[token("|", | _ | OpCode :: BitOr)]
        #[token("^", | _ | OpCode :: BitXor)]
        #[token("==", | _ | OpCode :: Eq)]
        #[token("!=", | _ | OpCode :: Ne)]
        #[token("<", | _ | OpCode :: Lt)]
        #[token("<=", | _ | OpCode :: Le)]
        #[token(">", | _ | OpCode :: Gt)]
        #[token(">=", | _ | OpCode :: Ge)]
        #[token("&&", | _ | OpCode :: And)]
        #[token("||", | _ | OpCode :: Or)]
        #[token("=", | _ | OpCode :: Assign)]
        #[token("+=", | _ | OpCode :: AddAssign)]
        #[token("-=", | _ | OpCode :: SubAssign)]
        #[token("*=", | _ | OpCode :: MulAssign)]
        #[token("/=", | _ | OpCode :: DivAssign)]
        #[token("%=", | _ | OpCode :: ModAssign)]
        #[token("<<=", | _ | OpCode :: ShlAssign)]
        #[token(">>=", | _ | OpCode :: ShrAssign)]
        #[token("&=", | _ | OpCode :: BitAndAssign)]
        #[token("|=", | _ | OpCode :: BitOrAssign)]
        #[token("^=", | _ | OpCode :: BitXorAssign)]
        Op(OpCode),

        #[default]
        #[token("\n", handle_newlien)]
        Eof:{hello there},
        Err,
    }
    #[automatically_derived]
    impl ::core::default::Default for TokenKind {
        #[inline]
        fn default() -> TokenKind {
            Self::Eof
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TokenKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                TokenKind::If => ::core::fmt::Formatter::write_str(f, "If"),
                TokenKind::Else => ::core::fmt::Formatter::write_str(f, "Else"),
                TokenKind::Loop => ::core::fmt::Formatter::write_str(f, "Loop"),
                TokenKind::Ret => ::core::fmt::Formatter::write_str(f, "Ret"),
                TokenKind::For => ::core::fmt::Formatter::write_str(f, "For"),
                TokenKind::In => ::core::fmt::Formatter::write_str(f, "In"),
                TokenKind::Unknown => ::core::fmt::Formatter::write_str(f, "Unknown"),
                TokenKind::True => ::core::fmt::Formatter::write_str(f, "True"),
                TokenKind::False => ::core::fmt::Formatter::write_str(f, "False"),
                TokenKind::Dot => ::core::fmt::Formatter::write_str(f, "Dot"),
                TokenKind::DoubleDot => ::core::fmt::Formatter::write_str(f, "DoubleDot"),
                TokenKind::Comma => ::core::fmt::Formatter::write_str(f, "Comma"),
                TokenKind::Semi => ::core::fmt::Formatter::write_str(f, "Semi"),
                TokenKind::Colon => ::core::fmt::Formatter::write_str(f, "Colon"),
                TokenKind::Enum => ::core::fmt::Formatter::write_str(f, "Enum"),
                TokenKind::Struct => ::core::fmt::Formatter::write_str(f, "Struct"),
                TokenKind::LBrace => ::core::fmt::Formatter::write_str(f, "LBrace"),
                TokenKind::RBrace => ::core::fmt::Formatter::write_str(f, "RBrace"),
                TokenKind::LBracket => ::core::fmt::Formatter::write_str(f, "LBracket"),
                TokenKind::RBracket => ::core::fmt::Formatter::write_str(f, "RBracket"),
                TokenKind::Tuple => ::core::fmt::Formatter::write_str(f, "Tuple"),
                TokenKind::LParen => ::core::fmt::Formatter::write_str(f, "LParen"),
                TokenKind::RParen => ::core::fmt::Formatter::write_str(f, "RParen"),
                TokenKind::Ident => ::core::fmt::Formatter::write_str(f, "Ident"),
                TokenKind::Import => ::core::fmt::Formatter::write_str(f, "Import"),
                TokenKind::Str => ::core::fmt::Formatter::write_str(f, "Str"),
                TokenKind::Int => ::core::fmt::Formatter::write_str(f, "Int"),
                TokenKind::Op(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Op", &__self_0)
                }
                TokenKind::Eof => ::core::fmt::Formatter::write_str(f, "Eof"),
                TokenKind::Err => ::core::fmt::Formatter::write_str(f, "Err"),
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TokenKind {
        #[inline]
        fn clone(&self) -> TokenKind {
            let _: ::core::clone::AssertParamIsClone<OpCode>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TokenKind {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TokenKind {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TokenKind {
        #[inline]
        fn eq(&self, other: &TokenKind) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (TokenKind::Op(__self_0), TokenKind::Op(__arg1_0)) => *__self_0 == *__arg1_0,
                    _ => true,
                }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for TokenKind {}
    #[automatically_derived]
    impl ::core::cmp::Eq for TokenKind {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<OpCode>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TokenKind {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                TokenKind::Op(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                _ => {}
            }
        }
    }
    impl<'s> ::logos::Logos<'s> for TokenKind {
        type Error = ();
        type Extras = Extras;
        type Source = str;
        fn lex(lex: &mut:{hello there} ::logos::Lexer<'s, Self>) {
            use ::logos::internal::{LexerInternal, CallbackResult};
            type Lexer<'s> = ::logos::Lexer<'s, TokenKind>;
            fn _end<'s>(lex: &mut Lexer<'s>) {
                lex.end()
            }
            fn _error<'s>(lex: &mut Lexer<'s>) {
                lex.bump_unchecked(1);
                lex.error();
            }
            static COMPACT_TABLE_0: [u8; 256] = [
                6, 6, 6, 6, 6, 6, 6, 6, 6, 2, 2, 6, 6, 2, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
                6, 6, 6, 6, 6, 6, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 15, 15, 15, 15, 15, 15,
                15, 15, 15, 15, 6, 6, 6, 6, 6, 6, 6, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
                15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 6, 4, 6, 6, 15, 6, 15,
                15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 7, 15, 15, 15, 15,
                15, 15, 15, 15, 6, 6, 2, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
                6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
                6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
                6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
                6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
            ];
            macro_rules! _fast_loop {
                ($lex : ident, $test : ident, $miss : expr) =>
                {
                    while let Some(arr) = $lex.read :: < & [u8 ; 16] > ()
                    {
                        if $test(arr [0])
                        {
                            if $test(arr [1])
                            {
                                if $test(arr [2])
                                {
                                    if $test(arr [3])
                                    {
                                        if $test(arr [4])
                                        {
                                            if $test(arr [5])
                                            {
                                                if $test(arr [6])
                                                {
                                                    if $test(arr [7])
                                                    {
                                                        if $test(arr [8])
                                                        {
                                                            if $test(arr [9])
                                                            {
                                                                if $test(arr [10])
                                                                {
                                                                    if $test(arr [11])
                                                                    {
                                                                        if $test(arr [12])
                                                                        {
                                                                            if $test(arr [13])
                                                                            {
                                                                                if $test(arr [14])
                                                                                {
                                                                                    if $test(arr [15]) { $lex.bump_unchecked(16) ; continue ; }
                                                                                    $lex.bump_unchecked(15) ; return $miss ;
                                                                                } $lex.bump_unchecked(14) ; return $miss ;
                                                                            } $lex.bump_unchecked(13) ; return $miss ;
                                                                        } $lex.bump_unchecked(12) ; return $miss ;
                                                                    } $lex.bump_unchecked(11) ; return $miss ;
                                                                } $lex.bump_unchecked(10) ; return $miss ;
                                                            } $lex.bump_unchecked(9) ; return $miss ;
                                                        } $lex.bump_unchecked(8) ; return $miss ;
                                                    } $lex.bump_unchecked(7) ; return $miss ;
                                                } $lex.bump_unchecked(6) ; return $miss ;
                                            } $lex.bump_unchecked(5) ; return $miss ;
                                        } $lex.bump_unchecked(4) ; return $miss ;
                                    } $lex.bump_unchecked(3) ; return $miss ;
                                } $lex.bump_unchecked(2) ; return $miss ;
                            } $lex.bump_unchecked(1) ; return $miss ;
                        } return $miss ;
                    } while $lex.test($test) { $lex.bump_unchecked(1) ; } $miss
                } ;
            }
            #[inline]
            fn goto20_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::Semi));
            }
            #[inline]
            fn goto59_ctx59_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::BitXor
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto78_ctx59_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::BitXorAssign
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto161_ctx59_x<'s>(lex: &mut Lexer<'s>) {
                match lex.read::<&[u8; 1usize]>() {
                    Some(b"=") => :{hello there}{
                        lex.bump_unchecked(1usize);
                        goto78_ctx59_x(lex)
                    }
                    _ => goto59_ctx59_x(lex),
                }
            }
            #[inline]
            fn goto31_ctx31_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::Ident));
            }
            #[inline]
            fn pattern0(byte: u8) -> bool {
                COMPACT_TABLE_0[byte as usize] & 1 > 0
            }
            #[inline]
            fn goto32_ctx31_x<'s>(lex: &mut Lexer<'s>) {
                while let Some(arr) = lex.read::<&[u8; 16]>() {
                    if pattern0(arr[0]) {
                        if pattern0(arr[1]) {
                            if pattern0(arr[2]) {
                                if pattern0(arr[3]) {
                                    if pattern0(arr[4]) {
                                        if pattern0(arr[5]) {
                                            if pattern0(arr[6]) {
                                                if pattern0(arr[7]) {
                                                    if pattern0(arr[8]) {
                                                        if pattern0(arr[9]) {
                                                            if pattern0(arr[10]) {
                                                                if pattern0(arr[11]) {
                                                                    if pattern0(arr[12]) {
                                                                        if pattern0(arr[13]) {
                                                                            if pattern0(arr[14]) {
                                                                                if pattern0(arr[15])
                                                                                {
                                                                                    lex.bump_unchecked(16);
                                                                                    continue;
                                                                                }
                                                                                lex.bump_unchecked(
                                                                                    15,
                                                                                );
                                                                                return goto31_ctx31_x(lex);
                                                                            }
                                                                            lex.bump_unchecked(14);
                                                                            return goto31_ctx31_x(
                                                                                lex,
                                                                            );
                                                                        }
                                                                        lex.bump_unchecked(13);
                                                                        return goto31_ctx31_x(lex);
                                                                    }
                                                                    lex.bump_unchecked(12);
                                                                    return goto31_ctx31_x(lex);
                                                                }
                                                                lex.bump_unchecked(11);
                                                                return goto31_ctx31_x(lex);
                                                            }
                                                            lex.bump_unchecked(10);
                                                            return goto31_ctx31_x(lex);
                                                        }
                                                        lex.bump_unchecked(9);
                                                        return goto31_ctx31_x(lex);
                                                    }
                                                    lex.bump_unchecked(8);
                                                    return goto31_ctx31_x(lex);
                                                }
                                                lex.bump_unchecked(7);
                                                return goto31_ctx31_x(lex);
                                            }
                                            lex.bump_unchecked(6);
                                            return goto31_ctx31_x(lex);
                                        }
                                        lex.bump_unchecked(5);
                                        return goto31_ctx31_x(lex);
                                    }
                                    lex.bump_unchecked(4);
                                    return goto31_ctx31_x(lex);
                                }
                                lex.bump_unchecked(3);
                                return goto31_ctx31_x(lex);
                            }
                            lex.bump_unchecked(2);
                            return goto31_ctx31_x(lex);
                        }
                        lex.bump_unchecked(1);
                        return goto31_ctx31_x(lex);
                    }
                    return goto31_ctx31_x(lex);
                }
                while lex.test(pattern0) {
                    lex.bump_unchecked(1);
                }
                goto31_ctx31_x(lex);
            }
            #[inline]
            fn goto8_ctx31_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::If));
            }
            #[inline]
            fn goto83_ctx31_x<'s>(lex: &mut Lexer<'s>) {
                let byte = match lex.read::<u8>:{hello there}() {
                    Some(byte) => byte,
                    None => return goto8_ctx31_x(lex),
                };
                match byte {
                    byte if pattern0(byte) => {
                        lex.bump_unchecked(1usize);
                        goto32_ctx31_x(lex)
                    }
                    _ => goto8_ctx31_x(lex),
                }
            }
            #[inline]
            fn goto13_ctx31_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::In));
            }
            #[inline]
            fn goto98_ctx31_x<'s>(lex: &mut Lexer<'s>) {
                let byte = match lex.read::<u8>() {
                    Some(byte) => byte,
                    None => return goto13_ctx31_x(lex),
                };
                match byte {
                    byte if pattern0(byte) => {
                        lex.bump_unchecked(1usize);
                        goto32_ctx31_x(lex)
                    }
                    _ => goto13_ctx31_x(lex),
                }
            }
            #[inline]
            fn goto97_ctx31_x<'s>(lex: &mut Lexer<'s>) {
                enum Jump {
                    __,
                    J32,
                    J83,
                    J98,
                }
                const LUT: [Jump; 256] = {
                    use Jump::*;
                    [
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, J32, J32, J32, J32, J32, J32, J32,
                        J32, J32, J32, __, __, __, __, __, __, __, J32, J32, J32, J32, J32, J32,
                        J32, J32, J32, J32, J32, J32, J32, J32, J32, J32, J32, J32, J32, J32, J32,
                        J32, J32, J32, J32, J32, __, __, __, __, J32, __, J32, J32, J32, J32, J32,
                        J83, J32, J32, J32, J32, J32, J32, J32, J98, J32, J32, J32, J32, J32, J32,
                        J32, J32, J32, J32, J32, J32, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __,
                    ]
                };
                let byte = match lex.read::<u8>() {
                    Some(byte) => byte,
                    None => return goto31_ctx31_x(lex),
                };
                match LUT[byte as usize] {
                    Jump::J32 => {
                        lex.bump_unchecked(1usize);
                        goto32_ctx31_x(lex)
                    }
                    Jump::J83 => {
                        lex.bump_unchecked(1usize);
                        goto83_ctx31_x(lex)
                    }
                    Jump::J98 => {
                        lex.bump_unchecked(1usize);
                        goto98_ctx31_x(lex)
                    }
                    Jump::__ => goto31_ctx31_x(lex),
                }
            }
            #[inline]
            fn goto17_ctx17_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::Dot));
            }
            #[inline]
            fn goto18_ctx17_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::DoubleDot));
            }
            #[inline]
            fn goto114_ctx17_x<'s>(lex: &mut Lexer<'s>) {
                match lex.read::<&[u8; 1usize]>() {
                    Some(b".") => {
                        lex.bump_unchecked(1usize);
                        goto18_ctx17_x(lex)
                    }
                    _ => goto17_ctx17_x(lex),
                }
            }
            #[inline]
            fn goto79_x<'s>(lex: &mut Lexer<'s>) {
                handle_newlien(lex).construct(|()| TokenKind::Eof, lex);
            }
            #[inline:{hello there}]
            fn goto61_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::Ne
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto126_at1<'s>(lex: &mut Lexer<'s>) {
                match lex.read_at::<&[u8; 1usize]>(1usize) {
                    Some(b"=") => {
                        lex.bump_unchecked(2usize);
                        goto61_x(lex)
                    }
                    _ => _error(lex),
                }
            }
            #[inline]
            fn goto50_ctx50_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::Mul
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto28_ctx50_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::Tuple));
            }
            #[inline]
            fn goto71_ctx50_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::MulAssign
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto23_ctx50_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::Struct));
            }
            #[inline]
            fn goto143_ctx50_x<'s>(lex: &mut Lexer<'s>) {
                enum Jump {
                    __,
                    J28,
                    J71,
                    J23,
                }
                const LUT: [Jump; 256] = {
                    use Jump::*;
                    [
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, J28, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, J71, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, J23, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __,
                    ]
                };
                let byte = match lex.read::<u8>() {
                    Some(byte) => byte,
                    None => return goto50_ctx50_x(lex),
                };
                match LUT[byte as usize] {
                    Jump::J28 => {
                        lex.bump_unchecked(1usize);
                        goto28_ctx50_x(lex)
                    }
                    Jump::J71 => {
                        lex.bump_unchecked(1usize);
                        goto71_ctx50_x(lex)
                    }
                    Jump::J23 => {
                        lex.bump_unchecked(1usize);
                        goto23_ctx50_x(lex)
                    }
                    Jump::__ => goto50_ctx50_x(lex),
                }
            }
            #[inline]
            fn goto10_ctx32_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::Loop));
            }
            #[inline]
            fn goto89_ctx32_x<'s>(lex: &mut Lexer<'s>) {
                let byte = match lex.read::<u8>() {
                    Some(byte) => byte,
                    None => return goto10_ctx32_x(lex),
                };
                match byte {
                    byte if patte:{hello there}rn0(byte) => {
                        lex.bump_unchecked(1usize);
                        goto32_ctx31_x(lex)
                    }
                    _ => goto10_ctx32_x(lex),
                }
            }
            #[inline]
            fn goto88_ctx32_x<'s>(lex: &mut Lexer<'s>) {
                match lex.read::<&[u8; 3usize]>() {
                    Some(b"oop") => {
                        lex.bump_unchecked(3usize);
                        goto89_ctx32_x(lex)
                    }
                    _ => goto32_ctx31_x(lex),
                }
            }
            #[inline]
            fn goto53_ctx53_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::Add
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto69_ctx53_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::AddAssign
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto139_ctx53_x<'s>(lex: &mut Lexer<'s>) {
                match lex.read::<&[u8; 1usize]>() {
                    Some(b"=") => {
                        lex.bump_unchecked(1usize);
                        goto69_ctx53_x(lex)
                    }
                    _ => goto53_ctx53_x(lex),
                }
            }
            #[inline]
            fn goto24_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::LBrace));
            }
            #[inline]
            fn goto14_ctx32_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::Unknown));
            }
            #[inline]
            fn goto101_ctx32_x<'s>(lex: &mut Lexer<'s>) {
                let byte = match lex.read::<u8>() {
                    Some(byte) => byte,
                    None => return goto14_ctx32_x(lex),
                };
                match byte {
                    byte if pattern0(byte) => {
                        lex.bump_unchecked(1usize);
                        goto32_ctx31_x(lex)
                    }
                    _ => goto14_ctx32_x(lex),
                }
            }
            #[inline]
            fn goto100_ctx32_x<'s>(lex: &mut Lexer<'s>) {
                match lex.read::<&[u8; 6usize]>() {
                    Some(b"nknown") => {
                        lex.bump_unchecked(6usize);
                        goto101_ctx32_x(lex)
                    }
                    _ => goto32_ctx31_x(lex),
                }
            }
            #[inline]
            fn goto19_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::Comma));
            }
            #[inline]
            fn goto52_ctx52_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::Mod
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto73_ctx52_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::ModAssign
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto147_ctx52_x<'s>(lex: &mut Lexer<'s>) {
                match lex.read::<&[u8; 1usize]>() {
                    Some(b"=") => {
                        lex.bump_unchecked(1usize);
                        goto73_ctx52_x(lex:{hello there})
                    }
                    _ => goto52_ctx52_x(lex),
                }
            }
            #[inline]
            fn goto1_ctx1_x<'s>(lex: &mut Lexer<'s>) {
                lex.trivia();
                TokenKind::lex(lex);
            }
            #[inline]
            fn pattern1(byte: u8) -> bool {
                const LUT: u64 = 4294976000u64;
                match 1u64.checked_shl(byte as u32) {
                    Some(shift) => LUT & shift != 0,
                    None => false,
                }
            }
            #[inline]
            fn goto2_ctx1_x<'s>(lex: &mut Lexer<'s>) {
                while let Some(arr) = lex.read::<&[u8; 16]>() {
                    if pattern1(arr[0]) {
                        if pattern1(arr[1]) {
                            if pattern1(arr[2]) {
                                if pattern1(arr[3]) {
                                    if pattern1(arr[4]) {
                                        if pattern1(arr[5]) {
                                            if pattern1(arr[6]) {
                                                if pattern1(arr[7]) {
                                                    if pattern1(arr[8]) {
                                                        if pattern1(arr[9]) {
                                                            if pattern1(arr[10]) {
                                                                if pattern1(arr[11]) {
                                                                    if pattern1(arr[12]) {
                                                                        if pattern1(arr[13]) {
                                                                            if pattern1(arr[14]) {
                                                                                if pattern1(arr[15])
                                                                                {
                                                                                    lex.bump_unchecked(16);
                                                                                    continue;
                                                                                }
                                                                                lex.bump_unchecked(
                                                                                    15,
                                                                                );
                                                                                return goto1_ctx1_x(lex);
                                                                            }
                                                                            lex.bump_unchecked(14);
                                                                            return goto1_ctx1_x(
                                                                                lex,
                                                                            );
                                                                        }
                                                                        lex.bump_unchecked(13);
                                                                        return goto1_ctx1_x(lex);
                                                                    }
                                                                    lex.bump_unchecked(12);
                                                                    return goto1_ctx1_x(lex);
                                                                }
                                                                lex.bump_unchecked(11);
                                                                return goto1_ctx1_x(lex);
                                                            }
                                                            lex.bump_unchecked(10);
                                                            return goto1_ctx1_x(lex);
                                                        }
                                                        lex.bump_unchecked(9);
                                                        return goto1_ctx1_x(lex);
                                                    }
                                                    lex.bump_unchecked(8);
                                                    return goto1_ctx1_x(lex);
                                                }
                                                lex.bump_unchecked(7);
                                                return goto1_ctx1_x(lex);
                                            }
                                            lex.bump_unchecked(6);
                                            return goto1_ctx1_x(lex);
                                        }
                                        lex.bump_unchecked(5);
                                        return goto1_ctx1_x(lex);
                                    }
                                    lex.bump_unchecked(4);
                                    return goto1_ctx1_x(lex);
                                }
                                lex.bump_unchecked(3);
                                return goto1_ctx1_x(lex);
                            }
                            lex.bump_unchecked(2);
                            return goto1_ctx1_x(lex);
                        }
                        lex.bump_unchecked(1);
                        return goto1_ctx1_x(lex);
                    }
                    return goto1_ctx1_x(lex);
                }
                while lex.test(pattern1) {
                    lex.bump_unchecked(1);
                }
                goto1_ctx1_x(lex);
            }
            #[inline]
            fn goto58_ctx58_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> i:{hello there}mpl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::BitOr
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto77_ctx58_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::BitOrAssign
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto67_ctx58_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::Or
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto22_ctx58_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::Enum));
            }
            #[inline]
            fn goto159_ctx58_x<'s>(lex: &mut Lexer<'s>) {
                enum Jump {
                    __,
                    J77,
                    J67,
                    J22,
                }
                const LUT: [Jump; 256] = {
                    use Jump::*;
                    [
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, J77, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, J22, J67, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __,
                    ]
                };
                let byte = match lex.read::<u8>() {
                    Some(byte) => byte,
                    None => return goto58_ctx58_x(lex),
                };
                match LUT[byte as usize] {
                    Jump::J77 => {
                        lex.bump_unchecked(1usize);
                        goto77_ctx58_x(lex)
                    }
                    Jump::J67 => {
                        lex.bump_unchecked(1usize);
                        goto67_ctx58_x(lex)
                    }
                    Jump::J22 => {
                        lex.bump_unchecked(1usize);
                        goto22_ctx58_x(lex)
                    }
                    Jump::__ => goto58_ctx58_x(lex),
                }
            }
            #[inline]
            fn goto38_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::Str));
            }
            #[inline]
            fn goto39_x<'s>(lex: &mut Lexer<'s>) {
                match lex.read::<&[u8; 1usize]>() {
                    Some(b"\"") => {
                        lex.bump_unchecked(1usize);
                        goto38_x(lex)
                    }
                    _ => lex.error(),
                }
            }
            #[inline]
            fn goto38_ctx39_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::Str));
            }
            #[inline]
            fn goto39_ctx39_x<'s>(lex: &mut Lexer<'s>) {
                match lex.read::<&[u8; 1usize]>() {
                    Some(b"\"") => {
                        lex.bump_unchecked(1usize);
                        goto38_ctx39_x(lex)
                    }
                    _ => goto39_x(lex),
                }
            }
            #[inline:{hello there}]
            fn pattern2(byte: u8) -> bool {
                COMPACT_TABLE_0[byte as usize] & 2 > 0
            }
            #[inline]
            fn goto45_at1_ctx39_x<'s>(lex: &mut Lexer<'s>) {
                enum Jump {
                    __,
                    J40,
                    J44,
                    J38,
                }
                const LUT: [Jump; 256] = {
                    use Jump::*;
                    [
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J38, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J44, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40,
                    ]
                };
                let byte = match lex.read_at::<u8>(1usize) {
                    Some(byte) => byte,
                    None => {
                        return {
                            lex.bump_unchecked(1usize);
                            goto38_ctx39_x(lex)
                        }
                    }
                };
                match LUT[byte as usize] {
                    Jump::J40 => {
                        lex.bump_unchecked(2usize);
                        goto40_ctx39_x(lex)
                    }
                    Jump::J44 => {
                        lex.bump_unchecked(2usize);
                        goto44_ctx39_x(lex)
                    }
                    Jump::J38 => {
                        lex.bump_unchecked(2usize);
                        goto38_ctx39_x(lex)
                    }
                    Jump::__ => {
                        lex.bump_unchecked(1usize);
                        goto38_ctx39_x(lex)
                    }
                }
            }
            #[inline]
            fn goto44_ctx39_x<'s>(lex: &mut Lexer<'s>) {
                enum Jump {
                    __,
                    J45,
                    J40,
                    J44,
                }
                const LUT: [Jump; 256] = {
                    use Jump::*;
                    [
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J45, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J44, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40, J40,
                        J40,
                    ]
                };
                let byte = match lex.read::<u8>() {
                    Some(byte) => byte,
                    None => return goto39_x(lex),
                };
                match LUT[byte as usize] {
                    Jump::J45 => goto45_at1_ctx39_x(lex),
                    Jump::J40 => :{hello there}{
                        lex.bump_unchecked(1usize);
                        goto40_ctx39_x(lex)
                    }
                    Jump::J44 => {
                        lex.bump_unchecked(1usize);
                        goto44_ctx39_x(lex)
                    }
                    Jump::__ => goto39_x(lex),
                }
            }
            #[inline]
            fn goto40_ctx39_x<'s>(lex: &mut Lexer<'s>) {
                let byte = match lex.read::<u8>() {
                    Some(byte) => byte,
                    None => return goto39_ctx39_x(lex),
                };
                match byte {
                    byte if pattern2(byte) => {
                        lex.bump_unchecked(1usize);
                        goto40_ctx39_x(lex)
                    }
                    b'\\' => {
                        lex.bump_unchecked(1usize);
                        goto44_ctx39_x(lex)
                    }
                    _ => goto39_ctx39_x(lex),
                }
            }
            #[inline]
            fn goto27_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::RBracket));
            }
            #[inline]
            fn goto11_ctx32_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::Ret));
            }
            #[inline]
            fn goto92_ctx32_x<'s>(lex: &mut Lexer<'s>) {
                let byte = match lex.read::<u8>() {
                    Some(byte) => byte,
                    None => return goto11_ctx32_x(lex),
                };
                match byte {
                    byte if pattern0(byte) => {
                        lex.bump_unchecked(1usize);
                        goto32_ctx31_x(lex)
                    }
                    _ => goto11_ctx32_x(lex),
                }
            }
            #[inline]
            fn goto91_ctx32_x<'s>(lex: &mut Lexer<'s>) {
                match lex.read::<&[u8; 2usize]>() {
                    Some(b"et") => {
                        lex.bump_unchecked(2usize);
                        goto92_ctx32_x(lex)
                    }
                    _ => goto32_ctx31_x(lex),
                }
            }
            #[inline]
            fn goto15_ctx32_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::True));
            }
            #[inline]
            fn goto104_ctx32_x<'s>(lex: &mut Lexer<'s>) {
                let byte = match lex.read::<u8>() {
                    Some(byte) => byte,
                    None => return goto15_ctx32_x(lex),
                };
                match byte {
                    byte if pattern0(byte) => {
                        lex.bump_unchecked(1usize);
                        goto32_ctx31_x(lex)
                    }
                    _ => goto15_ctx32_x(lex),
                }
            }
            #[inline]
            fn goto103_ctx32_x<'s>(lex: &mut Lexer<'s>) {
                match lex.read::<&[u8; 3usize]>() {
                    Some(b"rue") => {
                        lex.bump_unchecked(3usize);
                        goto104_ctx32_x(lex)
                    }
                    _ => goto32_ctx31_x(lex),
                }
            }
            #[inline]
            fn goto47_ctx47_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::Int));
            }
            #[inline]
            fn pattern3(byte: u8) -> bool {
                match byte {
                    b'0'..=b'9' => true,
                    _ => false,
                }
            }
            #[inline:{hello there}]
            fn goto48_ctx47_x<'s>(lex: &mut Lexer<'s>) {
                while let Some(arr) = lex.read::<&[u8; 16]>() {
                    if pattern3(arr[0]) {
                        if pattern3(arr[1]) {
                            if pattern3(arr[2]) {
                                if pattern3(arr[3]) {
                                    if pattern3(arr[4]) {
                                        if pattern3(arr[5]) {
                                            if pattern3(arr[6]) {
                                                if pattern3(arr[7]) {
                                                    if pattern3(arr[8]) {
                                                        if pattern3(arr[9]) {
                                                            if pattern3(arr[10]) {
                                                                if pattern3(arr[11]) {
                                                                    if pattern3(arr[12]) {
                                                                        if pattern3(arr[13]) {
                                                                            if pattern3(arr[14]) {
                                                                                if pattern3(arr[15])
                                                                                {
                                                                                    lex.bump_unchecked(16);
                                                                                    continue;
                                                                                }
                                                                                lex.bump_unchecked(
                                                                                    15,
                                                                                );
                                                                                return goto47_ctx47_x(lex);
                                                                            }
                                                                            lex.bump_unchecked(14);
                                                                            return goto47_ctx47_x(
                                                                                lex,
                                                                            );
                                                                        }
                                                                        lex.bump_unchecked(13);
                                                                        return goto47_ctx47_x(lex);
                                                                    }
                                                                    lex.bump_unchecked(12);
                                                                    return goto47_ctx47_x(lex);
                                                                }
                                                                lex.bump_unchecked(11);
                                                                return goto47_ctx47_x(lex);
                                                            }
                                                            lex.bump_unchecked(10);
                                                            return goto47_ctx47_x(lex);
                                                        }
                                                        lex.bump_unchecked(9);
                                                        return goto47_ctx47_x(lex);
                                                    }
                                                    lex.bump_unchecked(8);
                                                    return goto47_ctx47_x(lex);
                                                }
                                                lex.bump_unchecked(7);
                                                return goto47_ctx47_x(lex);
                                            }
                                            lex.bump_unchecked(6);
                                            return goto47_ctx47_x(lex);
                                        }
                                        lex.bump_unchecked(5);
                                        return goto47_ctx47_x(lex);
                                    }
                                    lex.bump_unchecked(4);
                                    return goto47_ctx47_x(lex);
                                }
                                lex.bump_unchecked(3);
                                return goto47_ctx47_x(lex);
                            }
                            lex.bump_unchecked(2);
                            return goto47_ctx47_x(lex);
                        }
                        lex.bump_unchecked(1);
                        return goto47_ctx47_x(lex);
                    }
                    return goto47_ctx47_x(lex);
                }
                while lex.test(pattern3) {
                    lex.bump_unchecked(1);
                }
                goto47_ctx47_x(lex);
            }
            #[inline]
            fn goto54_ctx54_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::Sub
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto70_ctx54_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::SubAssign
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto141_ctx54_x<'s>(lex: &mut Lexer<'s>) {
                match lex.read::<&[u8; 1usize]>() {
                    Some(b"=") => {
                        lex.bump_unchecked(1usize);
                        goto70_ct:{hello there}x54_x(lex)
                    }
                    _ => goto54_ctx54_x(lex),
                }
            }
            #[inline]
            fn goto30_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::RParen));
            }
            #[inline]
            fn goto68_ctx68_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::Assign
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto60_ctx68_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::Eq
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto137_ctx68_x<'s>(lex: &mut Lexer<'s>) {
                match lex.read::<&[u8; 1usize]>() {
                    Some(b"=") => {
                        lex.bump_unchecked(1usize);
                        goto60_ctx68_x(lex)
                    }
                    _ => goto68_ctx68_x(lex),
                }
            }
            #[inline]
            fn goto26_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::LBracket));
            }
            #[inline]
            fn goto62_ctx62_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::Lt
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto55_ctx62_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::Shl
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto74_ctx62_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::ShlAssign
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto151_ctx62_x<'s>(lex: &mut Lexer<'s>) {
                match lex.read::<&[u8; 1usize]>() {
                    Some(b"=") => {
                        lex.bump_unchecked(1usize);
                        goto74_ctx62_x(lex)
                    }
                    _ => goto55_ctx62_x(lex),
                }
            }
            #[inline]
            fn goto63_ctx62_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::Le
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto149_ctx62_x<'s>(lex: &mut Lexer<'s>) {
                let byte = match lex.read::<u8>() {
                    Some(byte) => byte,
                    None => return goto62_ctx62_x(lex),
                };
                match byte {
                    b'<' => {
                        lex.bump_unchecked(1usize);
                        goto151_ctx62_x(lex)
                    }
                    b'=' => {
                        lex.bump_unchecked(1usize);
                        goto63_ctx62_x(lex)
                    }
                    _ => goto62_ctx62_x(lex),
                }
            }
            #[inline]
            fn goto9_ctx32_x<'s>(lex: &mut Lex:{hello there}er<'s>) {
                lex.set(Ok(TokenKind::Else));
            }
            #[inline]
            fn goto86_ctx32_x<'s>(lex: &mut Lexer<'s>) {
                let byte = match lex.read::<u8>() {
                    Some(byte) => byte,
                    None => return goto9_ctx32_x(lex),
                };
                match byte {
                    byte if pattern0(byte) => {
                        lex.bump_unchecked(1usize);
                        goto32_ctx31_x(lex)
                    }
                    _ => goto9_ctx32_x(lex),
                }
            }
            #[inline]
            fn goto85_ctx32_x<'s>(lex: &mut Lexer<'s>) {
                match lex.read::<&[u8; 3usize]>() {
                    Some(b"lse") => {
                        lex.bump_unchecked(3usize);
                        goto86_ctx32_x(lex)
                    }
                    _ => goto32_ctx31_x(lex),
                }
            }
            #[inline]
            fn goto51_ctx51_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::Div
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn pattern4(byte: u8) -> bool {
                match byte {
                    0u8..=9u8 | 11u8..=255u8 => true,
                    _ => false,
                }
            }
            #[inline]
            fn goto4_ctx1_x<'s>(lex: &mut Lexer<'s>) {
                while let Some(arr) = lex.read::<&[u8; 16]>() {
                    if pattern4(arr[0]) {
                        if pattern4(arr[1]) {
                            if pattern4(arr[2]) {
                                if pattern4(arr[3]) {
                                    if pattern4(arr[4]) {
                                        if pattern4(arr[5]) {
                                            if pattern4(arr[6]) {
                                                if pattern4(arr[7]) {
                                                    if pattern4(arr[8]) {
                                                        if pattern4(arr[9]) {
                                                            if pattern4(arr[10]) {
                                                                if pattern4(arr[11]) {
                                                                    if pattern4(arr[12]) {
                                                                        if pattern4(arr[13]) {
                                                                            if pattern4(arr[14]) {
                                                                                if pattern4(arr[15])
                                                                                {
                                                                                    lex.bump_unchecked(16);
                                                                                    continue;
                                                                                }
                                                                                lex.bump_unchecked(
                                                                                    15,
                                                                                );
                                                                                return goto1_ctx1_x(lex);
                                                                            }
                                                                            lex.bump_unchecked(14);
                                                                            return goto1_ctx1_x(
                                                                                lex,
                                                                            );
                                                                        }
                                                                        lex.bump_unchecked(13);
                                                                        return goto1_ctx1_x(lex);
                                                                    }
                                                                    lex.bump_unchecked(12);
                                                                    return goto1_ctx1_x(lex);
                                                                }
                                                                lex.bump_unchecked(11);
                                                                return goto1_ctx1_x(lex);
                                                            }
                                                            lex.bump_unchecked(10);
                                                            return goto1_ctx1_x(lex);
                                                        }
                                                        lex.bump_unchecked(9);
                                                        return goto1_ctx1_x(lex);
                                                    }
                                                    lex.bump_unchecked(8);
                                                    return goto1_ctx1_x(lex);
                                                }
                                                lex.bump_unchecked(7);
                                                return goto1_ctx1_x(lex);
                                            }
                                            lex.bump_unchecked(6);
                                            return goto1_ctx1_x(lex);
                                        }
                                        lex.bump_unchecked(5);
                                        return goto1_ctx1_x:{hello there}(lex);
                                    }
                                    lex.bump_unchecked(4);
                                    return goto1_ctx1_x(lex);
                                }
                                lex.bump_unchecked(3);
                                return goto1_ctx1_x(lex);
                            }
                            lex.bump_unchecked(2);
                            return goto1_ctx1_x(lex);
                        }
                        lex.bump_unchecked(1);
                        return goto1_ctx1_x(lex);
                    }
                    return goto1_ctx1_x(lex);
                }
                while lex.test(pattern4) {
                    lex.bump_unchecked(1);
                }
                goto1_ctx1_x(lex);
            }
            #[inline]
            fn goto72_ctx51_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::DivAssign
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto145_ctx51_x<'s>(lex: &mut Lexer<'s>) {
                let byte = match lex.read::<u8>() {
                    Some(byte) => byte,
                    None => return goto51_ctx51_x(lex),
                };
                match byte {
                    b'/' => {
                        lex.bump_unchecked(1usize);
                        goto4_ctx1_x(lex)
                    }
                    b'=' => {
                        lex.bump_unchecked(1usize);
                        goto72_ctx51_x(lex)
                    }
                    _ => goto51_ctx51_x(lex),
                }
            }
            #[inline]
            fn goto21_ctx21_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::Colon));
            }
            #[inline]
            fn goto34_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::Import));
            }
            #[inline]
            fn goto35_x<'s>(lex: &mut Lexer<'s>) {
                match lex.read::<&[u8; 1usize]>() {
                    Some(b"}") => {
                        lex.bump_unchecked(1usize);
                        goto34_x(lex)
                    }
                    _ => lex.error(),
                }
            }
            #[inline]
            fn goto34_ctx35_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::Import));
            }
            #[inline]
            fn goto35_ctx35_x<'s>(lex: &mut Lexer<'s>) {
                match lex.read::<&[u8; 1usize]>() {
                    Some(b"}") => {
                        lex.bump_unchecked(1usize);
                        goto34_ctx35_x(lex)
                    }
                    _ => goto35_x(lex),
                }
            }
            #[inline]
            fn pattern5(byte: u8) -> bool {
                COMPACT_TABLE_0[byte as usize] & 4 > 0
            }
            #[inline]
            fn goto36_ctx35_x<'s>(lex: &mut Lexer<'s>) {
                while let Some(arr) = lex.read::<&[u8; 16]>() {
                    if pattern5(arr[0]) {
                        if pattern5(arr[1]) {
                            if pattern5(arr[2]) {
                                if pattern5(arr[3]) {
                                    if pattern5(arr[4]) {
                                        if pattern5(arr[5]) {
                                            if pattern5(arr[6]) {
                                                if pattern5(arr[7]) {
                                                    if pattern5(arr[8]) {
                                                        if pattern5(arr[9]) {
                                                            if pattern5(arr[10]) {
                                                                if pattern5(arr[11]) {
                                                                    if pattern5(arr[12]) {
                                                                        if pattern5(arr[13]) {
                                                                        :{hello there}    if pattern5(arr[14]) {
                                                                                if pattern5(arr[15])
                                                                                {
                                                                                    lex.bump_unchecked(16);
                                                                                    continue;
                                                                                }
                                                                                lex.bump_unchecked(
                                                                                    15,
                                                                                );
                                                                                return goto35_ctx35_x(lex);
                                                                            }
                                                                            lex.bump_unchecked(14);
                                                                            return goto35_ctx35_x(
                                                                                lex,
                                                                            );
                                                                        }
                                                                        lex.bump_unchecked(13);
                                                                        return goto35_ctx35_x(lex);
                                                                    }
                                                                    lex.bump_unchecked(12);
                                                                    return goto35_ctx35_x(lex);
                                                                }
                                                                lex.bump_unchecked(11);
                                                                return goto35_ctx35_x(lex);
                                                            }
                                                            lex.bump_unchecked(10);
                                                            return goto35_ctx35_x(lex);
                                                        }
                                                        lex.bump_unchecked(9);
                                                        return goto35_ctx35_x(lex);
                                                    }
                                                    lex.bump_unchecked(8);
                                                    return goto35_ctx35_x(lex);
                                                }
                                                lex.bump_unchecked(7);
                                                return goto35_ctx35_x(lex);
                                            }
                                            lex.bump_unchecked(6);
                                            return goto35_ctx35_x(lex);
                                        }
                                        lex.bump_unchecked(5);
                                        return goto35_ctx35_x(lex);
                                    }
                                    lex.bump_unchecked(4);
                                    return goto35_ctx35_x(lex);
                                }
                                lex.bump_unchecked(3);
                                return goto35_ctx35_x(lex);
                            }
                            lex.bump_unchecked(2);
                            return goto35_ctx35_x(lex);
                        }
                        lex.bump_unchecked(1);
                        return goto35_ctx35_x(lex);
                    }
                    return goto35_ctx35_x(lex);
                }
                while lex.test(pattern5) {
                    lex.bump_unchecked(1);
                }
                goto35_ctx35_x(lex);
            }
            #[inline]
            fn goto115_ctx21_x<'s>(lex: &mut Lexer<'s>) {
                match lex.read::<&[u8; 1usize]>() {
                    Some(b"{") => {
                        lex.bump_unchecked(1usize);
                        goto36_ctx35_x(lex)
                    }
                    _ => goto21_ctx21_x(lex),
                }
            }
            #[inline]
            fn goto57_ctx57_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::BitAnd
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto76_ctx57_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::BitAndAssign
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto66_ctx57_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::And
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto157_ctx57_x<'s>(lex: &mut Lexer<'s>) {
                let byte = match lex.read::<u8>() {
                    Some(byte) => byte,
                    None => return goto57_ctx57_x(lex):{hello there},
                };
                match byte {
                    b'=' => {
                        lex.bump_unchecked(1usize);
                        goto76_ctx57_x(lex)
                    }
                    b'&' => {
                        lex.bump_unchecked(1usize);
                        goto66_ctx57_x(lex)
                    }
                    _ => goto57_ctx57_x(lex),
                }
            }
            #[inline]
            fn goto29_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::LParen));
            }
            #[inline]
            fn goto64_ctx64_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::Gt
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto65_ctx64_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::Ge
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto56_ctx64_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::Shr
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto75_ctx64_x<'s>(lex: &mut Lexer<'s>) {
                #[inline]
                fn callback<'s>(_: &mut Lexer<'s>) -> impl CallbackResult<'s, OpCode, TokenKind> {
                    OpCode::ShrAssign
                }
                callback(lex).construct(TokenKind::Op, lex);
            }
            #[inline]
            fn goto155_ctx64_x<'s>(lex: &mut Lexer<'s>) {
                match lex.read::<&[u8; 1usize]>() {
                    Some(b"=") => {
                        lex.bump_unchecked(1usize);
                        goto75_ctx64_x(lex)
                    }
                    _ => goto56_ctx64_x(lex),
                }
            }
            #[inline]
            fn goto153_ctx64_x<'s>(lex: &mut Lexer<'s>) {
                let byte = match lex.read::<u8>() {
                    Some(byte) => byte,
                    None => return goto64_ctx64_x(lex),
                };
                match byte {
                    b'=' => {
                        lex.bump_unchecked(1usize);
                        goto65_ctx64_x(lex)
                    }
                    b'>' => {
                        lex.bump_unchecked(1usize);
                        goto155_ctx64_x(lex)
                    }
                    _ => goto64_ctx64_x(lex),
                }
            }
            #[inline]
            fn goto25_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::RBrace));
            }
            #[inline]
            fn goto16_ctx31_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::False));
            }
            #[inline]
            fn goto110_ctx31_x<'s>(lex: &mut Lexer<'s>) {
                let byte = match lex.read::<u8>() {
                    Some(byte) => byte,
                    None => return goto16_ctx31_x(lex),
                };
                match byte {
                    byte if pattern0(byte) => {
                        lex.bump_unchecked(1usize);
                        goto32_ctx31_x(lex)
                    }
                    _ => goto16_ctx31_x(lex),
                }
            }
            #[inline:{hello there}]
            fn goto109_ctx31_x<'s>(lex: &mut Lexer<'s>) {
                match lex.read::<&[u8; 3usize]>() {
                    Some(b"lse") => {
                        lex.bump_unchecked(3usize);
                        goto110_ctx31_x(lex)
                    }
                    _ => goto32_ctx31_x(lex),
                }
            }
            #[inline]
            fn pattern6(byte: u8) -> bool {
                COMPACT_TABLE_0[byte as usize] & 8 > 0
            }
            #[inline]
            fn goto12_ctx31_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(TokenKind::For));
            }
            #[inline]
            fn goto95_ctx31_x<'s>(lex: &mut Lexer<'s>) {
                let byte = match lex.read::<u8>() {
                    Some(byte) => byte,
                    None => return goto12_ctx31_x(lex),
                };
                match byte {
                    byte if pattern0(byte) => {
                        lex.bump_unchecked(1usize);
                        goto32_ctx31_x(lex)
                    }
                    _ => goto12_ctx31_x(lex),
                }
            }
            #[inline]
            fn goto111_ctx31_x<'s>(lex: &mut Lexer<'s>) {
                let byte = match lex.read::<u8>() {
                    Some(byte) => byte,
                    None => return goto31_ctx31_x(lex),
                };
                match byte {
                    byte if pattern6(byte) => {
                        lex.bump_unchecked(1usize);
                        goto32_ctx31_x(lex)
                    }
                    b'r' => {
                        lex.bump_unchecked(1usize);
                        goto95_ctx31_x(lex)
                    }
                    _ => goto31_ctx31_x(lex),
                }
            }
            #[inline]
            fn goto106_ctx31_x<'s>(lex: &mut Lexer<'s>) {
                enum Jump {
                    __,
                    J109,
                    J32,
                    J111,
                }
                const LUT: [Jump; 256] = {
                    use Jump::*;
                    [
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, J32, J32, J32, J32, J32, J32, J32,
                        J32, J32, J32, __, __, __, __, __, __, __, J32, J32, J32, J32, J32, J32,
                        J32, J32, J32, J32, J32, J32, J32, J32, J32, J32, J32, J32, J32, J32, J32,
                        J32, J32, J32, J32, J32, __, __, __, __, J32, __, J109, J32, J32, J32, J32,
                        J32, J32, J32, J32, J32, J32, J32, J32, J32, J111, J32, J32, J32, J32, J32,
                        J32, J32, J32, J32, J32, J32, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __,
                    ]
                };
                let byte = match lex.read::<u8>() {
                    Some(byte) => byte,
                    None => return goto31_ctx31_x(lex),
                };
                match LUT[byte as usize] {
                    Jump::J109 => {
                        lex.bump_unchecked(1usize);
                        goto109_ctx31_x(lex)
                    }
                    Jump::J32 => {
                        lex.bump_unchecked(1usize);
                        goto32_ctx31_x(lex)
                    }
                    Jump::J111 => {
                        lex.bump_unchecked(1usize);
                        goto111_ctx31_x(lex)
                    }
                    Jump::__ => goto31_ctx31_x(lex),
                }
            }
            #[inline]
            fn goto162<'s>(lex: &mut Lexer<'s>) {
                enum Jump :{hello there}{
                    __,
                    J20,
                    J161,
                    J97,
                    J114,
                    J79,
                    J126,
                    J143,
                    J88,
                    J139,
                    J24,
                    J100,
                    J32,
                    J19,
                    J147,
                    J2,
                    J159,
                    J40,
                    J27,
                    J91,
                    J103,
                    J48,
                    J141,
                    J30,
                    J137,
                    J26,
                    J149,
                    J85,
                    J145,
                    J115,
                    J157,
                    J29,
                    J153,
                    J25,
                    J106,
                }
                const LUT: [Jump; 256] = {
                    use Jump::*;
                    [
                        __, __, __, __, __, __, __, __, __, J2, J79, __, __, J2, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, J2, J126, J40, __,
                        __, J147, J157, __, J29, J30, J143, J139, J19, J141, J114, J145, J48, J48,
                        J48, J48, J48, J48, J48, J48, J48, J48, J115, J20, J149, J137, J153, __,
                        __, J32, J32, J32, J32, J32, J32, J32, J32, J32, J32, J32, J32, J32, J32,
                        J32, J32, J32, J32, J32, J32, J32, J32, J32, J32, J32, J32, J26, __, J27,
                        J161, J32, __, J32, J32, J32, J32, J85, J106, J32, J32, J97, J32, J32, J88,
                        J32, J32, J32, J32, J32, J91, J32, J103, J100, J32, J32, J32, J32, J32,
                        J24, J159, J25, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __,
                        __,
                    ]
                };
                let byte = match lex.read::<u8>() {
                    Some(byte) => byte,
                    None => return _end(lex),
                };
                match LUT[byte as usize] {
                    Jump::J20 => {
                        lex.bump_unchecked(1usize);
                        goto20_x(lex)
                    }
                    Jump::J161 => {
                        lex.bump_unchecked(1usize);
                        goto161_ctx59_x(lex)
                    }
                    Jump::J97 => {
                        lex.bump_unchecked(1usize);
                        goto97_ctx31_x(lex)
                    }
                    Jump::J114 => {
                        lex.bump_unchecked(1usize);
                        goto114_ctx17_x(lex)
                    }
                    Jump::J79 => {
                        lex.bump_unchecked(1usize);
                        goto79_x(lex)
                    }
                    Jump::J126 => goto126_at1(lex),
                    Jump::J143 => {
                        lex.bump_unchecked(1usize);
                        goto143_ctx50_x(lex)
                    }
                    Jump::J88 => {
                        lex.bump_unchecked(1usize);
                        goto88_ctx32_x(lex)
                    }
                    Jump::J139 => {
                        lex.bump_unchecked(1usize);
                        goto139_ctx53_x(lex)
                    }
                    Jump::J24 => {
                        lex.bump_unchecked(1usize);
                        goto24_x(lex)
                    }
                    Jump::J100 => :{hello there}{
                        lex.bump_unchecked(1usize);
                        goto100_ctx32_x(lex)
                    }
                    Jump::J32 => {
                        lex.bump_unchecked(1usize);
                        goto32_ctx31_x(lex)
                    }
                    Jump::J19 => {
                        lex.bump_unchecked(1usize);
                        goto19_x(lex)
                    }
                    Jump::J147 => {
                        lex.bump_unchecked(1usize);
                        goto147_ctx52_x(lex)
                    }
                    Jump::J2 => {
                        lex.bump_unchecked(1usize);
                        goto2_ctx1_x(lex)
                    }
                    Jump::J159 => {
                        lex.bump_unchecked(1usize);
                        goto159_ctx58_x(lex)
                    }
                    Jump::J40 => {
                        lex.bump_unchecked(1usize);
                        goto40_ctx39_x(lex)
                    }
                    Jump::J27 => {
                        lex.bump_unchecked(1usize);
                        goto27_x(lex)
                    }
                    Jump::J91 => {
                        lex.bump_unchecked(1usize);
                        goto91_ctx32_x(lex)
                    }
                    Jump::J103 => {
                        lex.bump_unchecked(1usize);
                        goto103_ctx32_x(lex)
                    }
                    Jump::J48 => {
                        lex.bump_unchecked(1usize);
                        goto48_ctx47_x(lex)
                    }
                    Jump::J141 => {
                        lex.bump_unchecked(1usize);
                        goto141_ctx54_x(lex)
                    }
                    Jump::J30 => {
                        lex.bump_unchecked(1usize);
                        goto30_x(lex)
                    }
                    Jump::J137 => {
                        lex.bump_unchecked(1usize);
                        goto137_ctx68_x(lex)
                    }
                    Jump::J26 => {
                        lex.bump_unchecked(1usize);
                        goto26_x(lex)
                    }
                    Jump::J149 => {
                        lex.bump_unchecked(1usize);
                        goto149_ctx62_x(lex)
                    }
                    Jump::J85 => {
                        lex.bump_unchecked(1usize);
                        goto85_ctx32_x(lex)
                    }
                    Jump::J145 => {
                        lex.bump_unchecked(1usize);
                        goto145_ctx51_x(lex)
                    }
                    Jump::J115 => {
                        lex.bump_unchecked(1usize);
                        goto115_ctx21_x(lex)
                    }
                    Jump::J157 => {
                        lex.bump_unchecked(1usize);
                        goto157_ctx57_x(lex)
                    }
                    Jump::J29 => {
                        lex.bump_unchecked(1usize);
                        goto29_x(lex)
                    }
                    Jump::J153 => {
                        lex.bump_unchecked(1usize);
                        goto153_ctx64_x(lex)
                    }
                    Jump::J25 => {
                        lex.bump_unchecked(1usize);
                        goto25_x(lex)
                    }
                    Jump::J106 => {
                        lex.bump_unchecked(1usize);
                        goto106_ctx31_x(lex)
                    }
                    Jump::__ => _error(lex),
                }
            }
            goto162(lex)
        :{hello there}
    }
    impl TokenKind {
        pub const TOKEN_COUNT: usize = [
            "if",
            "else",
            "loop",
            "ret",
            "for",
            "in",
            "unknown",
            "true",
            "false",
            ".",
            "..",
            ",",
            ";",
            ":",
            "|{",
            "*{",
            "{",
            "}",
            "[",
            "]",
            "*(",
            "(",
            ")",
            r"(?&ident_start)(?&ident_content)*",
            r":\{[^\n\r\t}]*\}",
            r#""([^"]|\\")*""#,
            r"[0-9]+",
        ]
        .len();
        pub const ALL: &[Self] = &[
            Self::If,
            Self::Else,
            Self::Loop,
            Self::Ret,
            Self::For,
            Self::In,
            Self::Unknown,
            Self::True,
            Self::False,
            Self::Dot,
            Self::DoubleDot,
            Self::Comma,
            Self::Semi,
            Self::Colon,
            Self::Enum,
            Self::Struct,
            Self::LBrace,
            Self::RBrace,
            Self::LBracket,
            Self::RBracket,
            Self::Tuple,
            Self::LParen,
            Self::RParen,
            Self::Ident,
            Self::Import,
            Self::Str,
            Self::Int,
            Self::Op(OpCode::Mul),
            Self::Op(OpCode::Div),
            Self::Op(OpCode::Mod),
            Self::Op(OpCode::Add),
            Self::Op(OpCode::Sub),
            Self::Op(OpCode::Shl),
            Self::Op(OpCode::Shr),
            Self::Op(OpCode::BitAnd),
            Self::Op(OpCode::BitOr),
            Self::Op(OpCode::BitXor),
            Self::Op(OpCode::Eq),
            Self::Op(OpCode::Ne),
            Self::Op(OpCode::Lt),
            Self::Op(OpCode::Le),
            Self::Op(OpCode::Gt),
            Self::Op(OpCode::Ge),
            Self::Op(OpCode::And),
            Self::Op(OpCode::Or),
            Self::Op(OpCode::Assign),
            Self::Op(OpCode::AddAssign),
            Self::Op(OpCode::SubAssign),
            Self::Op(OpCode::MulAssign),
            Self::Op(OpCode::DivAssign),
            Self::Op(OpCode::ModAssign),
            Self::Op(OpCode::ShlAssign),
            Self::Op(OpCode::ShrAssign),
            Self::Op(OpCode::BitAndAssign),
            Self::Op(OpCode::BitOrAssign),
            Self::Op(OpCode::BitXorAssign),
            Self::Eof,
            Self::Err,
        ];
        pub fn name(self) -> &'static str {
            match self {
                Self::If => "if",
                Self::Else => "else",
                Self::Loop => "loop",
                Self::Ret => "ret",
                Self::For => "for",
                Self::{hello there}:In => "in",
                Self::Unknown => "unknown",
                Self::True => "true",
                Self::False => "false",
                Self::Dot => ".",
                Self::DoubleDot => "..",
                Self::Comma => ",",
                Self::Semi => ";",
                Self::Colon => ":",
                Self::Enum => "|{",
                Self::Struct => "*{",
                Self::LBrace => "{",
                Self::RBrace => "}",
                Self::LBracket => "[",
                Self::RBracket => "]",
                Self::Tuple => "*(",
                Self::LParen => "(",
                Self::RParen => ")",
                Self::Ident => "Ident",
                Self::Import => "Import",
                Self::Str => "Str",
                Self::Int => "Int",
                Self::Op(o) => o.name(),
                Self::Eof => "EOF",
                Self::Err => "Error",
            }
        }
    }
    pub enum OpCode {
        Mul,
        Div,
        Mod,
        Add,
        Sub,
        Shl,
        Shr,
        BitAnd,
        BitOr,
        BitXor,
        Eq,
        Ne,
        Lt,
        Le,
        Gt,
        Ge,
        And,
        Or,
        Assign,
        AddAssign,
        SubAssign,
        MulAssign,
        DivAssign,
        ModAssign,
        ShlAssign,
        ShrAssign,
        BitAndAssign,
        BitOrAssign,
        BitXorAssign,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for OpCode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    OpCode::Mul => "Mul",
                    OpCode::Div => "Div",
                    OpCode::Mod => "Mod",
                    OpCode::Add => "Add",
                    OpCode::Sub => "Sub",
                    OpCode::Shl => "Shl",
                    OpCode::Shr => "Shr",
                    OpCode::BitAnd => "BitAnd",
                    OpCode::BitOr => "BitOr",
                    OpCode::BitXor => "BitXor",
                    OpCode::Eq => "Eq",
                    OpCode::Ne => "Ne",
                    OpCode::Lt => "Lt",
                    OpCode::Le => "Le",
                    OpCode::Gt => "Gt",
                    OpCode::Ge => "Ge",
                    OpCode::And => "And",
                    OpCode::Or => "Or",
                    OpCode::Assign => "Assign",
                    OpCode::AddAssign => "AddAssign",
                    OpCode::SubAssign => "SubAssign",
                    OpCode::MulAssign => "MulAssign",
                    OpCode::DivAssign => "DivAssign",
                    OpCode::ModAssign => "ModAssign",
                    OpCode::ShlAssign => "ShlAssign",
                    OpCode::ShrAssign => "ShrAssign",
                    OpCode::BitAndAssign => "BitAndAssign",
                    OpCode::BitOrAssign => "BitOrAssign",
                    OpCode::BitXorAssign => "BitXorAssign",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for OpCode {
        #[inline:{hello there}]
        fn clone(&self) -> OpCode {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for OpCode {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for OpCode {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for OpCode {
        #[inline]
        fn eq(&self, other: &OpCode) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for OpCode {}
    #[automatically_derived]
    impl ::core::cmp::Eq for OpCode {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for OpCode {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    impl OpCode {
        pub fn name(self) -> &'static str {
            match self {
                Self::Mul => "*",
                Self::Div => "/",
                Self::Mod => "%",
                Self::Add => "+",
                Self::Sub => "-",
                Self::Shl => "<<",
                Self::Shr => ">>",
                Self::BitAnd => "&",
                Self::BitOr => "|",
                Self::BitXor => "^",
                Self::Eq => "==",
                Self::Ne => "!=",
                Self::Lt => "<",
                Self::Le => "<=",
                Self::Gt => ">",
                Self::Ge => ">=",
                Self::And => "&&",
                Self::Or => "||",
                Self::Assign => "=",
                Self::AddAssign => "+=",
                Self::SubAssign => "-=",
                Self::MulAssign => "*=",
                Self::DivAssign => "/=",
                Self::ModAssign => "%=",
                Self::ShlAssign => "<<=",
                Self::ShrAssign => ">>=",
                Self::BitAndAssign => "&=",
                Self::BitOrAssign => "|=",
                Self::BitXorAssign => "^=",
            }
        }
        pub fn prec(self) -> u8 {
            match self {
                Self::Mul | Self::Div | Self::Mod => 3,
                Self::Add | Self::Sub => 4,
                Self::Shl | Self::Shr => 5,
                Self::BitAnd | Self::BitOr | Self::BitXor => 6,
                Self::Eq | Self::Ne | Self::Lt | Self::Le | Self::Gt | Self::Ge => 7,
                Self::And | Self::Or => 8,
                Self::Assign
                | Self::AddAssign
                | Self::SubAssign
                | Self::MulAssign
                | Self::DivAssign
                | Self::ModAssign
                | Self::ShlAssign
                | Self::ShrAssign
                | Self::BitAndAssign
                | Self::BitOrAssign
                | Self::BitXorAssign => 9,
            }
        }
    }
    impl TokenKind {
        pub const ERROR: &str = "Error";
        pub fn lexer(input: &str) -> logos::Lexer<TokenKind> {
            logos::Logos::lexer(input)
        }
    }
    impl Display for TokenKind {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.write_str(self.name())
        }
    :{hello there}
    #[logos(skip "[^:{}]+")]
    pub enum DependencyTokenKind {
        #[regex(r":\{[^\n\r\t}]*\}")]
        #[regex("[:{}]", logos::skip)]
        Import,
    }
    impl<'s> ::logos::Logos<'s> for DependencyTokenKind {
        type Error = ();
        type Extras = ();
        type Source = str;
        fn lex(lex: &mut ::logos::Lexer<'s, Self>) {
            use ::logos::internal::{LexerInternal, CallbackResult};
            type Lexer<'s> = ::logos::Lexer<'s, DependencyTokenKind>;
            fn _end<'s>(lex: &mut Lexer<'s>) {
                lex.end()
            }
            fn _error<'s>(lex: &mut Lexer<'s>) {
                lex.bump_unchecked(1);
                lex.error();
            }
            static COMPACT_TABLE_0: [u8; 256] = [
                3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
                3, 3, 3, 3,
            ];
            macro_rules! _fast_loop {
                ($lex : ident, $test : ident, $miss : expr) =>
                {
                    while let Some(arr) = $lex.read :: < & [u8 ; 16] > ()
                    {
                        if $test(arr [0])
                        {
                            if $test(arr [1])
                            {
                                if $test(arr [2])
                                {
                                    if $test(arr [3])
                                    {
                                        if $test(arr [4])
                                        {
                                            if $test(arr [5])
                                            {
                                                if $test(arr [6])
                                                {
                                                    if $test(arr [7])
                                                    {
                                                        if $test(arr [8])
                                                        {
                                                            if $test(arr [9])
                                                            {
                                                                if $test(arr [10])
                                                                {
                                                                    if $test(arr [11])
                                                                    {
                                                                        if $test(arr [12])
                                                                        {
                                                                            if $test(arr [13])
                                                                            {
                                                                                if $test(arr [14])
                                                                                {
                                                                                    if $test(arr [15]) { $lex.bump_unchecked(16) ; continue ; }
                                                                                    $lex.bump_unchecked(15) ; return $miss ;
                                                                                } $lex.bump_unchecked(14) ; return $miss ;
                                                                            } $lex.bump_unchecked(13) ; return $miss ;
                                                                        } $lex.bump_unchecked(12) ; return $miss ;
                                                                    } $lex.bump_unchecked(11) ; return $miss ;
                                                                } $lex.bump_unchecked(10) ; return $miss ;
                                                            } $lex.bump_unchecked(9) ; return $miss ;
                                                        } $lex.bump_unchecked(8) ; return $miss ;
                                                    } $lex.bump_unchecked(7) ; return $miss ;
                                                } $lex.bump_unchecked(6) ; return $miss ;
                                            } $lex.bump_unchecked(5) ; return $miss ;
                                        } $lex.bump_unchecked(4) ; return $miss ;
                                    } $lex.bump_unchecked(3) ; return $miss ;
                                } $lex.bump_unchecked(2) ; return $miss ;
                            } $lex.bump_unchecked(1) ; return $miss ;
                        } return $miss ;
                    } while $lex.test($test) { $lex.bump_unchecked(1) ; } $miss
                } ;
            }
            #[inline]
            fn goto8_x<'s>(lex: &mut Lexer<'s>) {
                logos::skip(lex).construct(|()| DependencyTokenKind::Import, lex);
            }
            #[inline]
            fn goto8_ctx8_x<'s>(lex: &mut Lexer<'s>) {
                logos::skip(lex).construct(|()| DependencyTokenKind::Import, lex);
            }
            #[inline]
            fn goto4_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(DependencyTokenKind::Import));
            }
            #[inl:{hello there}ine]
            fn goto5_x<'s>(lex: &mut Lexer<'s>) {
                match lex.read::<&[u8; 1usize]>() {
                    Some(b"}") => {
                        lex.bump_unchecked(1usize);
                        goto4_x(lex)
                    }
                    _ => lex.error(),
                }
            }
            #[inline]
            fn goto4_ctx5_x<'s>(lex: &mut Lexer<'s>) {
                lex.set(Ok(DependencyTokenKind::Import));
            }
            #[inline]
            fn goto5_ctx5_x<'s>(lex: &mut Lexer<'s>) {
                match lex.read::<&[u8; 1usize]>() {
                    Some(b"}") => {
                        lex.bump_unchecked(1usize);
                        goto4_ctx5_x(lex)
                    }
                    _ => goto5_x(lex),
                }
            }
            #[inline]
            fn pattern0(byte: u8) -> bool {
                COMPACT_TABLE_0[byte as usize] & 1 > 0
            }
            #[inline]
            fn goto6_ctx5_x<'s>(lex: &mut Lexer<'s>) {
                while let Some(arr) = lex.read::<&[u8; 16]>() {
                    if pattern0(arr[0]) {
                        if pattern0(arr[1]) {
                            if pattern0(arr[2]) {
                                if pattern0(arr[3]) {
                                    if pattern0(arr[4]) {
                                        if pattern0(arr[5]) {
                                            if pattern0(arr[6]) {
                                                if pattern0(arr[7]) {
                                                    if pattern0(arr[8]) {
                                                        if pattern0(arr[9]) {
                                                            if pattern0(arr[10]) {
                                                                if pattern0(arr[11]) {
                                                                    if pattern0(arr[12]) {
                                                                        if pattern0(arr[13]) {
                                                                            if pattern0(arr[14]) {
                                                                                if pattern0(arr[15])
                                                                                {
                                                                                    lex.bump_unchecked(16);
                                                                                    continue;
                                                                                }
                                                                                lex.bump_unchecked(
                                                                                    15,
                                                                                );
                                                                                return goto5_ctx5_x(lex);
                                                                            }
                                                                            lex.bump_unchecked(14);
                                                                            return goto5_ctx5_x(
                                                                                lex,
                                                                            );
                                                                        }
                                                                        lex.bump_unchecked(13);
                                                                        return goto5_ctx5_x(lex);
                                                                    }
                                                                    lex.bump_unchecked(12);
                                                                    return goto5_ctx5_x(lex);
                                                                }
                                                                lex.bump_unchecked(11);
                                                                return goto5_ctx5_x(lex);
                                                            }
                                                            lex.bump_unchecked(10);
                                                            return goto5_ctx5_x(lex);
                                                        }
                                                        lex.bump_unchecked(9);
                                                        return goto5_ctx5_x(lex);
                                                    }
                                                    lex.bump_unchecked(8);
                                                    return goto5_ctx5_x(lex);
                                                }
                                                lex.bump_unchecked(7);
                                                return goto5_ctx5_x(lex);
                                            }
                                            lex.bump_unchecked(6);
                                            return goto5_ctx5_x(lex);
                                        }
                                        lex.bump_unchecked(5);
                                        return goto5_ctx5_x(lex);
                                    }
                                    lex.bump_unchecked(4);
                                    return goto5_ctx5_x(lex);
                                }
                                lex.bump_unchecked(3);
                                return goto5_ctx5_x(lex);
                            }
                            lex.bump_unchecked(2);
                            return goto5_ctx5_x(lex);
                        }
                        lex.bump_unchecked(1);
                        return goto5_ctx5_x(lex);
                    }
                    return got:{hello there}o5_ctx5_x(lex);
                }
                while lex.test(pattern0) {
                    lex.bump_unchecked(1);
                }
                goto5_ctx5_x(lex);
            }
            #[inline]
            fn goto11_ctx8_x<'s>(lex: &mut Lexer<'s>) {
                match lex.read::<&[u8; 1usize]>() {
                    Some(b"{") => {
                        lex.bump_unchecked(1usize);
                        goto6_ctx5_x(lex)
                    }
                    _ => goto8_ctx8_x(lex),
                }
            }
            #[inline]
            fn goto1_ctx1_x<'s>(lex: &mut Lexer<'s>) {
                lex.trivia();
                DependencyTokenKind::lex(lex);
            }
            #[inline]
            fn pattern1(byte: u8) -> bool {
                COMPACT_TABLE_0[byte as usize] & 2 > 0
            }
            #[inline]
            fn goto2_ctx1_x<'s>(lex: &mut Lexer<'s>) {
                while let Some(arr) = lex.read::<&[u8; 16]>() {
                    if pattern1(arr[0]) {
                        if pattern1(arr[1]) {
                            if pattern1(arr[2]) {
                                if pattern1(arr[3]) {
                                    if pattern1(arr[4]) {
                                        if pattern1(arr[5]) {
                                            if pattern1(arr[6]) {
                                                if pattern1(arr[7]) {
                                                    if pattern1(arr[8]) {
                                                        if pattern1(arr[9]) {
                                                            if pattern1(arr[10]) {
                                                                if pattern1(arr[11]) {
                                                                    if pattern1(arr[12]) {
                                                                        if pattern1(arr[13]) {
                                                                            if pattern1(arr[14]) {
                                                                                if pattern1(arr[15])
                                                                                {
                                                                                    lex.bump_unchecked(16);
                                                                                    continue;
                                                                                }
                                                                                lex.bump_unchecked(
                                                                                    15,
                                                                                );
                                                                                return goto1_ctx1_x(lex);
                                                                            }
                                                                            lex.bump_unchecked(14);
                                                                            return goto1_ctx1_x(
                                                                                lex,
                                                                            );
                                                                        }
                                                                        lex.bump_unchecked(13);
                                                                        return goto1_ctx1_x(lex);
                                                                    }
                                                                    lex.bump_unchecked(12);
                                                                    return goto1_ctx1_x(lex);
                                                                }
                                                                lex.bump_unchecked(11);
                                                                return goto1_ctx1_x(lex);
                                                            }
                                                            lex.bump_unchecked(10);
                                                            return goto1_ctx1_x(lex);
                                                        }
                                                        lex.bump_unchecked(9);
                                                        return goto1_ctx1_x(lex);
                                                    }
                                                    lex.bump_unchecked(8);
                                                    return goto1_ctx1_x(lex);
                                                }
                                                lex.bump_unchecked(7);
                                                return goto1_ctx1_x(lex);
                                            }
                                            lex.bump_unchecked(6);
                                            return goto1_ctx1_x(lex);
                                        }
                                        lex.bump_unchecked(5);
                                        return goto1_ctx1_x(lex);
                                    }
                                    lex.bump_unchecked(4);
                                    return goto1_ctx1_x(lex);
                                }
                                lex.bump_unchecked(3);
                                return goto1_ctx1_x(lex);
                            }
                            lex.bump_unchecked(2);
                            return goto1_ctx1_x(lex);
                        }
                        lex.bump_unchecked(1);
                        return goto1_ctx1_x(lex);
                    }
                    return goto1_ctx1_x(lex);
                }
                while lex.test(pattern1) :{hello there}{
                    lex.bump_unchecked(1);
                }
                goto1_ctx1_x(lex);
            }
            #[inline]
            fn goto12<'s>(lex: &mut Lexer<'s>) {
                enum Jump {
                    __,
                    J8,
                    J11,
                    J2,
                }
                const LUT: [Jump; 256] = {
                    use Jump::*;
                    [
                        J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2,
                        J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2,
                        J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2,
                        J2, J11, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2,
                        J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2,
                        J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2,
                        J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J8, J2, J8, J2, J2, J2, J2, J2, J2,
                        J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2,
                        J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2,
                        J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2,
                        J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2,
                        J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2,
                        J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2, J2,
                        J2, J2, J2, J2, J2, J2, J2, J2, J2, J2,
                    ]
                };
                let byte = match lex.read::<u8>() {
                    Some(byte) => byte,
                    None => return _end(lex),
                };
                match LUT[byte as usize] {
                    Jump::J8 => {
                        lex.bump_unchecked(1usize);
                        goto8_x(lex)
                    }
                    Jump::J11 => {
                        lex.bump_unchecked(1usize);
                        goto11_ctx8_x(lex)
                    }
                    Jump::J2 => {
                        lex.bump_unchecked(1usize);
                        goto2_ctx1_x(lex)
                    }
                    Jump::__ => _error(lex),
                }
            }
            goto12(lex)
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DependencyTokenKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Import")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DependencyTokenKind {
        #[inline]
        fn clone(&self) -> DependencyTokenKind {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for DependencyTokenKind {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DependencyTokenKind {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DependencyTokenKind {
        #[inline]
        fn eq(&self, other: &DependencyTokenKind) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for DependencyTokenKind {}
    #[automatically_derived]
    impl ::core::cmp::Eq for DependencyTokenKind {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
}
mod parser {
    use std::fmt::Display;
    use mini_alloc::{ArenaScope, Diver, InternedStr, StrInterner};
    use crate::{Diagnostics, ExprAst, FileRef, Files, IdentAst, Lexer, Severty::*, Token, TokenKind};
    pub mod expr {
        use std::fmt::Display;
        use mini_alloc::{Diver, InternedStr};
        use crate::Severty::*;
        use crate::Token;
        use crate::TokenKind::*;
        use crate::TransposeOpt;
        use crate::{lexer::OpCode, Parser, Span}:{hello there};
        use super::StringParseError;
        impl<'ctx, 'src, 'arena> Parser<'ctx, 'src, 'arena> {
            pub(super) fn expr(&mut self, mut diver: Diver) -> Option<ExprAst<'arena>> {
                let unit = ExprAst::Unit(self.unit(diver.untyped_dive())?);
                self.binary(diver, unit, u8::MAX)
            }
            fn binary(
                &mut self,
                mut diver: Diver,
                mut lhs: ExprAst<'arena>,
                prev_prec: u8,
            ) -> Option<ExprAst<'arena>> {
                while let Token { kind: Op(kind), span, .. } = self.peek() &&
                        kind.prec() <= prev_prec {
                    self.next();
                    let mut rhs =
                        ExprAst::Unit(self.unit(diver.untyped_dive())?);
                    rhs = self.binary(diver.untyped_dive(), rhs, kind.prec())?;
                    lhs =
                        ExprAst::Binary(self.arena.alloc(BinaryAst {
                                    lhs,
                                    rhs,
                                    op: OpAst { span, kind },
                                }));
                }
                Some(lhs)
            }
            fn unit(&mut self, mut diver: Diver) -> Option<UnitAst<'arena>> {
                let token = self.next();
                fn unex_tok(parser: &mut Parser, span: Token, message: &str) -> Option<!> {
                    parser
                        .diags
                        .builder(parser.files)
                        .footer(Error, message)
                        .annotation(Error, span.span, format_args!("unexpected {0}", span.kind))
                        .terminate()
                }
                let expr = match token.kind {
                    If => self.if_(diver.untyped_dive()),
                    Else => unex_tok(self, token, "else can only follow an if")?,
                    Loop => self.loop_(diver.untyped_dive()),
                    Ret => self.ret(diver.untyped_dive()),
                    For => self.for_(diver.untyped_dive()),
                    In => unex_tok(self, token, "in can only follow a for")?,
                    Unknown => Some(UnitAst::Unknown(token.span)),
                    Dot => unex_tok(
                        self,
                        token,
                        "dot can only follow an expression of labeled keyword",
                    )?,
                    DoubleDot => unex_tok(
                        self,
                        token,
                        "double dot can only follow an expression of labeled keyword",
                    )?,
                    Comma => unex_tok(self, token, "comma can only follow an expression")?,
                    Semi => unex_tok(
                        self,
                        token,
                        "semicolon can only follow an expression inside a block",
                    )?,
                    Colon => unex_tok(self, token, "colon can only follow pattern")?,
                    Enum => self.enum_(diver.untyped_dive()),
                    Struct => self.struct_(diver.untyped_dive()),
                    LBrace => self.block(diver.untyped_dive()),
                    RBrace => unex_tok(self, token, "unmatched right brace")?,
                    LBracket => self.array(diver.untyped_dive()),
                    RBracket => unex_tok(self, token, "unmatched right bracket")?,
                    Tuple => self.tuple(diver.untyped_dive()),
                    LParen => self.paren(diver.untyped_dive()),
                    RParen => unex_tok(self, token, "unmatched right parenthesis")?,
                    Ident => Some(UnitAst::Ident(IdentAst {
                        span: token.span,
                        name: self.interner.intern(token.source),
                    })),
                    Import => Some(UnitAst::Import({
                        let source = &token.source
                            [Import.name().len()..token.source.len() - RBracket.name().len()];
                        let import = IdentAst {
                            span: token.span,
                            name: self.interner.intern(source),
                        };
                        self.imports.push(import);
                        import
                    })),
                    Str => self.str(token),
                    Int => self.int(token),
                    True => self.bool(true, token.span),
                    False => self.bool(false, token.span),
                    Op(op) => self.unary(
                        diver.untyped_dive(),
                        OpAst {
                            span: token.span,
                            kind: op,
                        },
                    ),
                    Eof => unex_tok(self, token, "got eof when expression is expected")?,
                    Err => unex_tok(self, token, "got error token when expression is expected")?,
                }?;
                self.handle_postfix(diver, expr:{hello there})
            }
            fn bool(&mut self, value: bool, span: Span) -> Option<UnitAst<'arena>> {
                Some(UnitAst::Literal(LiteralAst {
                    kind: LiteralKindAst::Bool(value),
                    span,
                }))
            }
            fn tuple(&mut self, diver: Diver) -> Option<UnitAst<'arena>> {
                let (exprs, ..) =
                    self.sequence(diver, Self::expr, Comma, RParen, "tuple element")?;
                Some(UnitAst::Tuple(exprs))
            }
            fn handle_postfix(
                &mut self,
                mut diver: Diver,
                mut expr: UnitAst<'arena>,
            ) -> Option<UnitAst<'arena>> {
                loop {
                    let token = self.peek();
                    expr =
                        match token.kind {
                            Dot => {
                                self.next();
                                let field = self.ident("field")?;
                                UnitAst::FieldAccess(self.arena.alloc(FieldAccessAst {
                                            expr,
                                            field,
                                        }))
                            }
                            LParen => {
                                self.next();
                                let args =
                                    &*self.sequence(diver.untyped_dive(), Self::expr, Comma,
                                                        RParen, "function parameter")?.0;
                                UnitAst::Call(self.arena.alloc(CallAst {
                                            callee: expr,
                                            args,
                                        }))
                            }
                            LBracket => {
                                self.next();
                                let index = self.expr(diver.untyped_dive())?;
                                self.expect_advance(RBracket, "closing index operator");
                                UnitAst::Index(self.arena.alloc(IndexAst { expr, index }))
                            }
                            Colon if let UnitAst::Ident(name) = expr => {
                                self.next();
                                let expr = self.expr(diver.untyped_dive())?;
                                break
                                    Some(UnitAst::Decl(self.arena.alloc(NamedExpr {
                                                    name,
                                                    expr,
                                                })))
                            }
                            _ => break Some(expr),
                        }
                }
            }
            fn unary(&mut self, diver: Diver, op: OpAst) -> Option<UnitAst<'arena>> {
                match op.kind {
                    OpCode::Or => self.func(diver, false),
                    OpCode::BitOr => self.func(diver, true),
                    _ => {
                        let expr = ExprAst::Unit(self.unit(diver)?);
                        Some(UnitAst::Unary(self.arena.alloc(UnaryAst { op, expr })))
                    }
                }
            }
            fn func(&mut self, mut diver: Diver, has_args: bool) -> Option<UnitAst<'arena>> {
                let args = match has_args {
                    true => {
                        &*self
                            .sequence(
                                diver.untyped_dive(),
                                Self::func_arg,
                                Comma,
                                Op(OpCode::BitOr),
                                "function parameter",
                            )?
                            .0
                    }
                    false => &[],
                };
                let body = self.expr(diver)?;
                Some(UnitAst::Func(self.arena.alloc(FuncAst { args, body })))
            }
            fn func_arg(&mut self, diver: Diver) -> Option<FuncArgAst<'arena>> {
                let name = self.ident("parameter name")?;
                let default = self
                    .try_advance(Op(OpCode::Assign))
                    .map(|_| self.unit(diver))
                    .transpose()?;
                Some(FuncArgAst { name, default })
            }
            fn int(&mut self, token: Token<'src>) -> Option<UnitAst<'arena>> {
                let value = token
                    .source
                    .parse::<u64>()
                    .expect("lexer should have validated int");
                Some(UnitAst::Literal(LiteralAst :{hello there}{
                    span: token.span,
                    kind: LiteralKindAst::Int(value.to_ne_bytes()),
                }))
            }
            fn str(&mut self, token: Token<'src>) -> Option<UnitAst<'arena>> {
                let delim_len = '"'.len_utf8();
                let source = &token.source[delim_len..token.source.len() - delim_len];
                Some(UnitAst::Literal(LiteralAst {
                    span: token.span,
                    kind: match self.string_parser.parse(&source, self.interner) {
                        Ok(name) => LiteralKindAst::Str(name),
                        Result::Err(StringParseError::IncompleteEscape) => {
                            self.diags
                                .builder(self.files)
                                .footer(Error, "incomplete escape sequence")
                                .annotation(Error, token.span, "in string literal")
                                .terminate()?;
                        }
                        Result::Err(StringParseError::InvalidEscape(index)) => {
                            self.diags
                                .builder(self.files)
                                .footer(Error, "invalid escape sequence")
                                .annotation(Error, token.span.shift(index), "in string literal")
                                .terminate()?;
                        }
                    },
                }))
            }
            fn paren(&mut self, mut diver: Diver) -> Option<UnitAst<'arena>> {
                let expr = self.expr(diver.untyped_dive())?;
                self.expect_advance(RParen, "right parenthesis")?;
                Some(UnitAst::Paren(self.arena.alloc(expr)))
            }
            fn array(&mut self, mut diver: Diver) -> Option<UnitAst<'arena>> {
                if self.try_advance(RBracket).is_some() {
                    return Some(UnitAst::Array(&[]));
                }
                let first = self.expr(diver.untyped_dive())?;
                if self.try_advance(Semi).is_some() {
                    let len = self.expr(diver.untyped_dive())?;
                    self.expect_advance(RBracket, "end of filled array")?;
                    return Some(UnitAst::FilledArray(
                        self.arena.alloc(FilledArrayAst { expr: first, len }),
                    ));
                }
                let mut elems = diver.dive::<ExprAst<'arena>>();
                elems.push(first);
                while self.try_advance(Comma).is_some() && self.peek().kind != RBracket {
                    let expr = self.expr(elems.untyped_dive())?;
                    elems.push(expr);
                }
                self.expect_advance(RBracket, "end of array")?;
                Some(UnitAst::Array(self.arena.alloc_rev_iter(elems)))
            }
            fn block(&mut self, diver: Diver) -> Option<UnitAst<'arena>> {
                let (exprs, trailing_semi) =
                    self.sequence(diver, Self::expr, Semi, RBrace, "block")?;
                Some(UnitAst::Block(self.arena.alloc(BlockAst {
                    exprs,
                    trailing_semi,
                })))
            }
            fn struct_(&mut self, diver: Diver) -> Option<UnitAst<'arena>> {
                let (fields, ..) =
                    self.sequence(diver, Self::struct_field, Comma, RBrace, "struct decl")?;
                Some(UnitAst::Struct(fields))
            }
            fn struct_field(&mut self, diver: Diver) -> Option<StructField<'arena>> {
                let peek = self.peek();
                match peek.kind {
                    Ident => {
                        let name = self.ident("struct field name")?;
                        let value = self
                            .try_advance(Colon)
                            .map(|_| self.expr(diver))
                            .transpose()?;
                        Some(match value {
                            Some(value) => StructField::Decl(NamedExpr { name, expr: value }),
                            None => StructField::Inline(name),
                        })
                    }
                    DoubleDot => {
                        self.next();
                        let expr = self.expr(diver)?;
                        Some(StructField::Embed(expr))
                    }
                    _ => self
                        .diags
                        .builder(self.files)
                        .footer(
                            Error,
                            "struct field can either start with '..' for embeding or identifier",
                        )
                        .annotation(Error, peek.span, format_args!("unexpected {0}", peek.kind))
                        .terminate()?,
                }
            }
            fn enum_(&mut self, mut diver: Diver) -> Option<UnitAst<'arena>> {
                let name = self.ident("enum name")?;
                let value = sel:{hello there}f
                    .try_advance(Colon)
                    .map(|_| self.expr(diver.untyped_dive()))
                    .transpose()?;
                self.expect_advance(RBrace, "closing the enum")?;
                Some(UnitAst::Enum(self.arena.alloc(EnumAst { name, value })))
            }
            fn for_(&mut self, mut diver: Diver) -> Option<UnitAst<'arena>> {
                let label = self.label("for")?;
                let var = self.ident("for loop variable")?;
                self.expect_advance(In, "expected in after for")?;
                let iter = self.expr(diver.untyped_dive())?;
                let body = self.expr(diver)?;
                Some(UnitAst::ForLoop(self.arena.alloc(ForLoopAst {
                    label,
                    var,
                    iter,
                    body,
                })))
            }
            fn ret(&mut self, diver: Diver) -> Option<UnitAst<'arena>> {
                Some(UnitAst::Ret(
                    (self.peek().kind != Semi)
                        .then(|| self.expr(diver))
                        .transpose()?
                        .map(|expr| &*self.arena.alloc(expr)),
                ))
            }
            fn if_(&mut self, mut diver: Diver) -> Option<UnitAst<'arena>> {
                let cond = self.expr(diver.untyped_dive())?;
                let then = self.expr(diver.untyped_dive())?;
                let else_ = self
                    .try_advance(Else)
                    .map(|_| self.expr(diver))
                    .transpose()?;
                Some(UnitAst::If(self.arena.alloc(IfAst { cond, then, else_ })))
            }
            fn loop_(&mut self, diver: Diver) -> Option<UnitAst<'arena>> {
                Some(UnitAst::Loop(self.arena.alloc(LoopAst {
                    label: self.label("loop")?,
                    body: self.expr(diver)?,
                })))
            }
            fn label(&mut self, objective: impl Display) -> Option<Option<IdentAst>> {
                self.try_advance(Dot)
                    .map(|_| self.ident(format_args!("{0} label", objective)))
                    .transpose()
            }
            fn ident(&mut self, objective: impl Display) -> Option<IdentAst> {
                let token = self.expect_advance(
                    Ident,
                    format_args!("expected identifier for {0}", objective),
                )?;
                Some(IdentAst {
                    span: token.span,
                    name: self.interner.intern(token.source),
                })
            }
        }
        pub enum ExprAst<'arena> {
            Unit(UnitAst<'arena>),
            Binary(&'arena BinaryAst<'arena>),
        }
        #[automatically_derived]
        impl<'arena> ::core::fmt::Debug for ExprAst<'arena> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    ExprAst::Unit(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Unit", &__self_0)
                    }
                    ExprAst::Binary(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Binary", &__self_0)
                    }
                }
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::clone::Clone for ExprAst<'arena> {
            #[inline]
            fn clone(&self) -> ExprAst<'arena> {
                let _: ::core::clone::AssertParamIsClone<UnitAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<&'arena BinaryAst<'arena>>;
                *self
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::marker::Copy for ExprAst<'arena> {}
        pub enum UnitAst<'arena> {
            Literal(LiteralAst),
            Ident(IdentAst),
            Import(IdentAst),
            Str(IdentAst),
            Block(&'arena BlockAst<'arena>),
            Unary(&'arena UnaryAst<'arena>),
            Array(&'arena [ExprAst<'arena>]),
            FilledArray(&'arena FilledArrayAst<'arena>),
            Tuple(&'arena [ExprAst<'arena>]),
            Struct(&'arena [StructField<'arena>]),
            Enum(&'arena EnumAst<'arena>),
            Call(&'arena CallAst<'arena>),
            Func(&'arena FuncAst<'arena>):{hello there},
            Decl(&'arena NamedExpr<'arena>),
            Loop(&'arena LoopAst<'arena>),
            Index(&'arena IndexAst<'arena>),
            ForLoop(&'arena ForLoopAst<'arena>),
            Break(&'arena BreakAst<'arena>),
            Continue(ContinueAst),
            FieldAccess(&'arena FieldAccessAst<'arena>),
            If(&'arena IfAst<'arena>),
            Ret(Option<&'arena ExprAst<'arena>>),
            Paren(&'arena ExprAst<'arena>),
            Unknown(Span),
        }
        #[automatically_derived]
        impl<'arena> ::core::fmt::Debug for UnitAst<'arena> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    UnitAst::Literal(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Literal", &__self_0)
                    }
                    UnitAst::Ident(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Ident", &__self_0)
                    }
                    UnitAst::Import(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Import", &__self_0)
                    }
                    UnitAst::Str(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Str", &__self_0)
                    }
                    UnitAst::Block(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Block", &__self_0)
                    }
                    UnitAst::Unary(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Unary", &__self_0)
                    }
                    UnitAst::Array(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Array", &__self_0)
                    }
                    UnitAst::FilledArray(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "FilledArray",
                            &__self_0,
                        )
                    }
                    UnitAst::Tuple(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Tuple", &__self_0)
                    }
                    UnitAst::Struct(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Struct", &__self_0)
                    }
                    UnitAst::Enum(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Enum", &__self_0)
                    }
                    UnitAst::Call(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Call", &__self_0)
                    }
                    UnitAst::Func(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Func", &__self_0)
                    }
                    UnitAst::Decl(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Decl", &__self_0)
                    }
                    UnitAst::Loop(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Loop", &__self_0)
                    }
                    UnitAst::Index(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Index", &__self_0)
                    }
                    UnitAst::ForLoop(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "ForLoop", &__self_0)
                    }
                    UnitAst::Break(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Break", &__self_0)
                    }
                    UnitAst::Continue(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Continue", &__self_0)
                    }
                    UnitAst::FieldAccess(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "FieldAccess",
                            &__self_0,
                        )
                    }
                    UnitAst::If(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "If", &__self_0)
                    }
                    UnitAst::Ret(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Ret", &__self_0)
                    }
                    UnitAst::Paren(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Paren", &__self_0)
                    }
                    UnitAst::Unknown(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Unknown", &__self_0)
                    }
                }
            }
        }
        #[automatically_derived:{hello there}]
        impl<'arena> ::core::clone::Clone for UnitAst<'arena> {
            #[inline]
            fn clone(&self) -> UnitAst<'arena> {
                let _: ::core::clone::AssertParamIsClone<LiteralAst>;
                let _: ::core::clone::AssertParamIsClone<IdentAst>;
                let _: ::core::clone::AssertParamIsClone<&'arena BlockAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<&'arena UnaryAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<&'arena [ExprAst<'arena>]>;
                let _: ::core::clone::AssertParamIsClone<&'arena FilledArrayAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<&'arena [ExprAst<'arena>]>;
                let _: ::core::clone::AssertParamIsClone<&'arena [StructField<'arena>]>;
                let _: ::core::clone::AssertParamIsClone<&'arena EnumAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<&'arena CallAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<&'arena FuncAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<&'arena NamedExpr<'arena>>;
                let _: ::core::clone::AssertParamIsClone<&'arena LoopAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<&'arena IndexAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<&'arena ForLoopAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<&'arena BreakAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<ContinueAst>;
                let _: ::core::clone::AssertParamIsClone<&'arena FieldAccessAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<&'arena IfAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<Option<&'arena ExprAst<'arena>>>;
                let _: ::core::clone::AssertParamIsClone<&'arena ExprAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<Span>;
                *self
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::marker::Copy for UnitAst<'arena> {}
        pub struct IndexAst<'arena> {
            pub expr: UnitAst<'arena>,
            pub index: ExprAst<'arena>,
        }
        #[automatically_derived]
        impl<'arena> ::core::fmt::Debug for IndexAst<'arena> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "IndexAst",
                    "expr",
                    &self.expr,
                    "index",
                    &&self.index,
                )
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::clone::Clone for IndexAst<'arena> {
            #[inline]
            fn clone(&self) -> IndexAst<'arena> {
                let _: ::core::clone::AssertParamIsClone<UnitAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<ExprAst<'arena>>;
                *self
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::marker::Copy for IndexAst<'arena> {}
        pub struct BlockAst<'arena> {
            pub exprs: &'arena [ExprAst<'arena>],
            pub trailing_semi: bool,
        }
        #[automatically_derived]
        impl<'arena> ::core::fmt::Debug for BlockAst<'arena> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "BlockAst",
                    "exprs",
                    &self.exprs,
                    "trailing_semi",
                    &&self.trailing_semi,
                )
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::clone::Clone for BlockAst<'arena> {
            #[inline]
            fn clone(&self) -> BlockAst<'arena> {
                let _: ::core::clone::AssertParamIsClone<&'arena [ExprAst<'arena>]>;
                let _: ::core::clone::AssertParamIsClone<bool>;
                *self
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::marker::Copy for BlockAst<'arena> {}
        pub struct EnumAst<'arena> {
            pub name: IdentAst,
            pub value: Option<ExprAst<'arena>>,
        }
        #[automatically_derived]
        impl<'arena> ::core::fmt::Debug for EnumAst<'arena> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "EnumAst",
                    "name",
                    &self.name,
                    "value",
                    &&self.value:{hello there},
                )
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::clone::Clone for EnumAst<'arena> {
            #[inline]
            fn clone(&self) -> EnumAst<'arena> {
                let _: ::core::clone::AssertParamIsClone<IdentAst>;
                let _: ::core::clone::AssertParamIsClone<Option<ExprAst<'arena>>>;
                *self
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::marker::Copy for EnumAst<'arena> {}
        pub struct IfAst<'arena> {
            pub cond: ExprAst<'arena>,
            pub then: ExprAst<'arena>,
            pub else_: Option<ExprAst<'arena>>,
        }
        #[automatically_derived]
        impl<'arena> ::core::fmt::Debug for IfAst<'arena> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "IfAst",
                    "cond",
                    &self.cond,
                    "then",
                    &self.then,
                    "else_",
                    &&self.else_,
                )
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::clone::Clone for IfAst<'arena> {
            #[inline]
            fn clone(&self) -> IfAst<'arena> {
                let _: ::core::clone::AssertParamIsClone<ExprAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<ExprAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<Option<ExprAst<'arena>>>;
                *self
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::marker::Copy for IfAst<'arena> {}
        pub struct FieldAccessAst<'arena> {
            pub expr: UnitAst<'arena>,
            pub field: IdentAst,
        }
        #[automatically_derived]
        impl<'arena> ::core::fmt::Debug for FieldAccessAst<'arena> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "FieldAccessAst",
                    "expr",
                    &self.expr,
                    "field",
                    &&self.field,
                )
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::clone::Clone for FieldAccessAst<'arena> {
            #[inline]
            fn clone(&self) -> FieldAccessAst<'arena> {
                let _: ::core::clone::AssertParamIsClone<UnitAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<IdentAst>;
                *self
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::marker::Copy for FieldAccessAst<'arena> {}
        pub struct ForLoopAst<'arena> {
            pub label: Option<IdentAst>,
            pub var: IdentAst,
            pub iter: ExprAst<'arena>,
            pub body: ExprAst<'arena>,
        }
        #[automatically_derived]
        impl<'arena> ::core::fmt::Debug for ForLoopAst<'arena> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "ForLoopAst",
                    "label",
                    &self.label,
                    "var",
                    &self.var,
                    "iter",
                    &self.iter,
                    "body",
                    &&self.body,
                )
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::clone::Clone for ForLoopAst<'arena> {
            #[inline:{hello there}]
            fn clone(&self) -> ForLoopAst<'arena> {
                let _: ::core::clone::AssertParamIsClone<Option<IdentAst>>;
                let _: ::core::clone::AssertParamIsClone<IdentAst>;
                let _: ::core::clone::AssertParamIsClone<ExprAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<ExprAst<'arena>>;
                *self
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::marker::Copy for ForLoopAst<'arena> {}
        pub struct LoopAst<'arena> {
            pub body: ExprAst<'arena>,
            pub label: Option<IdentAst>,
        }
        #[automatically_derived]
        impl<'arena> ::core::fmt::Debug for LoopAst<'arena> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "LoopAst",
                    "body",
                    &self.body,
                    "label",
                    &&self.label,
                )
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::clone::Clone for LoopAst<'arena> {
            #[inline]
            fn clone(&self) -> LoopAst<'arena> {
                let _: ::core::clone::AssertParamIsClone<ExprAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<Option<IdentAst>>;
                *self
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::marker::Copy for LoopAst<'arena> {}
        pub struct BreakAst<'arena> {
            pub label: Option<IdentAst>,
            pub expr: Option<ExprAst<'arena>>,
        }
        #[automatically_derived]
        impl<'arena> ::core::fmt::Debug for BreakAst<'arena> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "BreakAst",
                    "label",
                    &self.label,
                    "expr",
                    &&self.expr,
                )
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::clone::Clone for BreakAst<'arena> {
            #[inline]
            fn clone(&self) -> BreakAst<'arena> {
                let _: ::core::clone::AssertParamIsClone<Option<IdentAst>>;
                let _: ::core::clone::AssertParamIsClone<Option<ExprAst<'arena>>>;
                *self
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::marker::Copy for BreakAst<'arena> {}
        pub struct ContinueAst {
            pub label: Option<IdentAst>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ContinueAst {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ContinueAst",
                    "label",
                    &&self.label,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ContinueAst {
            #[inline]
            fn clone(&self) -> ContinueAst {
                let _: ::core::clone::AssertParamIsClone<Option<IdentAst>>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for ContinueAst {}
        pub enum StructField<'arena> {
            Decl(NamedExpr<'arena>),
            Inline(IdentAst),
            Embed(ExprAst<'arena>),
        }
        #[automatically_derived]
        impl<'arena> ::core::fmt::Debug for StructField<'arena> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    StructField:::{hello there}Decl(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Decl", &__self_0)
                    }
                    StructField::Inline(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Inline", &__self_0)
                    }
                    StructField::Embed(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Embed", &__self_0)
                    }
                }
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::clone::Clone for StructField<'arena> {
            #[inline]
            fn clone(&self) -> StructField<'arena> {
                let _: ::core::clone::AssertParamIsClone<NamedExpr<'arena>>;
                let _: ::core::clone::AssertParamIsClone<IdentAst>;
                let _: ::core::clone::AssertParamIsClone<ExprAst<'arena>>;
                *self
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::marker::Copy for StructField<'arena> {}
        pub struct UnaryAst<'arena> {
            pub op: OpAst,
            pub expr: ExprAst<'arena>,
        }
        #[automatically_derived]
        impl<'arena> ::core::fmt::Debug for UnaryAst<'arena> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "UnaryAst",
                    "op",
                    &self.op,
                    "expr",
                    &&self.expr,
                )
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::clone::Clone for UnaryAst<'arena> {
            #[inline]
            fn clone(&self) -> UnaryAst<'arena> {
                let _: ::core::clone::AssertParamIsClone<OpAst>;
                let _: ::core::clone::AssertParamIsClone<ExprAst<'arena>>;
                *self
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::marker::Copy for UnaryAst<'arena> {}
        pub struct FuncAst<'arena> {
            pub args: &'arena [FuncArgAst<'arena>],
            pub body: ExprAst<'arena>,
        }
        #[automatically_derived]
        impl<'arena> ::core::fmt::Debug for FuncAst<'arena> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "FuncAst",
                    "args",
                    &self.args,
                    "body",
                    &&self.body,
                )
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::clone::Clone for FuncAst<'arena> {
            #[inline]
            fn clone(&self) -> FuncAst<'arena> {
                let _: ::core::clone::AssertParamIsClone<&'arena [FuncArgAst<'arena>]>;
                let _: ::core::clone::AssertParamIsClone<ExprAst<'arena>>;
                *self
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::marker::Copy for FuncAst<'arena> {}
        pub struct FuncArgAst<'arena> {
            pub name: IdentAst,
            pub default: Option<UnitAst<'arena>>,
        }
        #[automatically_derived]
        impl<'arena> ::core::fmt::Debug for FuncArgAst<'arena> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "FuncArgAst",
                    "name",
                    &self.name,
                    "default",
                    &&self.default,
                )
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::clone::Clone for FuncArgAst<'arena> {
            #[inline]
            fn clone(&self) -> FuncArgAst<'are:{hello there}na> {
                let _: ::core::clone::AssertParamIsClone<IdentAst>;
                let _: ::core::clone::AssertParamIsClone<Option<UnitAst<'arena>>>;
                *self
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::marker::Copy for FuncArgAst<'arena> {}
        pub struct CallAst<'arena> {
            pub callee: UnitAst<'arena>,
            pub args: &'arena [ExprAst<'arena>],
        }
        #[automatically_derived]
        impl<'arena> ::core::fmt::Debug for CallAst<'arena> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "CallAst",
                    "callee",
                    &self.callee,
                    "args",
                    &&self.args,
                )
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::clone::Clone for CallAst<'arena> {
            #[inline]
            fn clone(&self) -> CallAst<'arena> {
                let _: ::core::clone::AssertParamIsClone<UnitAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<&'arena [ExprAst<'arena>]>;
                *self
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::marker::Copy for CallAst<'arena> {}
        pub struct NamedExpr<'arena> {
            pub name: IdentAst,
            pub expr: ExprAst<'arena>,
        }
        #[automatically_derived]
        impl<'arena> ::core::fmt::Debug for NamedExpr<'arena> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "NamedExpr",
                    "name",
                    &self.name,
                    "expr",
                    &&self.expr,
                )
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::clone::Clone for NamedExpr<'arena> {
            #[inline]
            fn clone(&self) -> NamedExpr<'arena> {
                let _: ::core::clone::AssertParamIsClone<IdentAst>;
                let _: ::core::clone::AssertParamIsClone<ExprAst<'arena>>;
                *self
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::marker::Copy for NamedExpr<'arena> {}
        pub struct FilledArrayAst<'arena> {
            pub expr: ExprAst<'arena>,
            pub len: ExprAst<'arena>,
        }
        #[automatically_derived]
        impl<'arena> ::core::fmt::Debug for FilledArrayAst<'arena> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "FilledArrayAst",
                    "expr",
                    &self.expr,
                    "len",
                    &&self.len,
                )
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::clone::Clone for FilledArrayAst<'arena> {
            #[inline]
            fn clone(&self) -> FilledArrayAst<'arena> {
                let _: ::core::clone::AssertParamIsClone<ExprAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<ExprAst<'arena>>;
                *self
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::marker::Copy for FilledArrayAst<'arena> {}
        pub struct BinaryAst<'arena> {
            pub lhs: ExprAst<'arena>,
            pub rhs: ExprAst<'arena>,
            pub op: OpAst,
        }
        #[automatically_derived]
        impl<'arena> ::core::fmt::Debug for BinaryAst<'arena> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3:{hello there}_finish(
                    f,
                    "BinaryAst",
                    "lhs",
                    &self.lhs,
                    "rhs",
                    &self.rhs,
                    "op",
                    &&self.op,
                )
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::clone::Clone for BinaryAst<'arena> {
            #[inline]
            fn clone(&self) -> BinaryAst<'arena> {
                let _: ::core::clone::AssertParamIsClone<ExprAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<ExprAst<'arena>>;
                let _: ::core::clone::AssertParamIsClone<OpAst>;
                *self
            }
        }
        #[automatically_derived]
        impl<'arena> ::core::marker::Copy for BinaryAst<'arena> {}
        pub struct OpAst {
            pub kind: OpCode,
            pub span: Span,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for OpAst {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "OpAst",
                    "kind",
                    &self.kind,
                    "span",
                    &&self.span,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for OpAst {
            #[inline]
            fn clone(&self) -> OpAst {
                let _: ::core::clone::AssertParamIsClone<OpCode>;
                let _: ::core::clone::AssertParamIsClone<Span>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for OpAst {}
        pub struct LiteralAst {
            pub kind: LiteralKindAst,
            pub span: Span,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for LiteralAst {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "LiteralAst",
                    "kind",
                    &self.kind,
                    "span",
                    &&self.span,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for LiteralAst {
            #[inline]
            fn clone(&self) -> LiteralAst {
                let _: ::core::clone::AssertParamIsClone<LiteralKindAst>;
                let _: ::core::clone::AssertParamIsClone<Span>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for LiteralAst {}
        pub enum LiteralKindAst {
            Int([u8; 8]),
            Str(InternedStr),
            Bool(bool),
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for LiteralKindAst {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    LiteralKindAst::Int(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Int", &__self_0)
                    }
                    LiteralKindAst::Str(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Str", &__self_0)
                    }
                    LiteralKindAst::Bool(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Bool", &__self_0)
                    }
                }
            }
        :{hello there}
        #[automatically_derived]
        impl ::core::clone::Clone for LiteralKindAst {
            #[inline]
            fn clone(&self) -> LiteralKindAst {
                let _: ::core::clone::AssertParamIsClone<[u8; 8]>;
                let _: ::core::clone::AssertParamIsClone<InternedStr>;
                let _: ::core::clone::AssertParamIsClone<bool>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for LiteralKindAst {}
        pub struct IdentAst {
            pub name: InternedStr,
            pub span: Span,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for IdentAst {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "IdentAst",
                    "name",
                    &self.name,
                    "span",
                    &&self.span,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for IdentAst {
            #[inline]
            fn clone(&self) -> IdentAst {
                let _: ::core::clone::AssertParamIsClone<InternedStr>;
                let _: ::core::clone::AssertParamIsClone<Span>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for IdentAst {}
    }
    pub mod fmt {
        use crate::*;
        use mini_alloc::*;
        pub fn format_ast(
            ast: &[ExprAst],
            ctx: &mut String,
            indent: usize,
            interner: &StrInterner,
        ) {
            for &ast in ast {
                format_expr(ast, ctx, indent, interner);
                ctx.push_str(";\n");
            }
        }
        fn format_expr(ast: ExprAst, ctx: &mut String, indent: usize, interner: &StrInterner) {
            match ast {
                ExprAst::Unit(u) => format_unit(u, ctx, indent, interner),
                ExprAst::Binary(&b) => format_binary(b, ctx, indent, interner),
            }
        }
        fn format_binary(
            binary: BinaryAst,
            ctx: &mut String,
            indent: usize,
            interner: &StrInterner,
        ) {
            ctx.push('(');
            format_expr(binary.lhs, ctx, indent, interner);
            ctx.push(' ');
            ctx.push_str(binary.op.kind.name());
            ctx.push(' ');
            format_expr(binary.rhs, ctx, indent, interner);
            ctx.push(')');
        }
        fn indent_f(ctx: &mut String, indent: usize) {
            for _ in 0..indent {
                ctx.push_str("    ");
            }
        }
        fn format_list<T: Copy>(
            list: &[T],
            ctx: &mut String,
            indent: usize,
            interner: &StrInterner,
            [start, sep, end]: [TokenKind; 3],
            indented: bool,
            trailing: bool,
            mut fmt: impl FnMut(T, &mut String, usize, &StrInterner),
        ) {
            ctx.push_str(start.name());
            let Some((last, list)) =
                list.split_last() else { ctx.push_str(end.name()); return; };
            if indented {
                ctx.push('\n');
            }
            for &item in list {
                if indented {
                    indent_f(ctx, indent + 1);
                :{hello there}
                fmt(item, ctx, indent + indented as usize, interner);
                ctx.push_str(sep.name());
                if indented {
                    ctx.push('\n');
                } else {
                    ctx.push(' ');
                }
            }
            if indented {
                indent_f(ctx, indent + 1);
            }
            fmt(*last, ctx, indent + indented as usize, interner);
            if trailing {
                ctx.push_str(sep.name());
            }
            if indented {
                ctx.push('\n');
            }
            if indented {
                indent_f(ctx, indent);
            }
            ctx.push_str(end.name());
        }
        pub fn format_unit(unit: UnitAst, ctx: &mut String, indent: usize, interner: &StrInterner) {
            match unit {
                UnitAst::Literal(l) => match l.kind {
                    LiteralKindAst::Int(i) => ctx.push_str(&u64::from_ne_bytes(i).to_string()),
                    LiteralKindAst::Bool(b) => ctx.push_str(&b.to_string()),
                    LiteralKindAst::Str(s) => ctx.push_str(&interner[s]),
                },
                UnitAst::Import(ident) | UnitAst::Str(ident) | UnitAst::Ident(ident) => {
                    ctx.push_str(&interner[ident.name])
                }
                UnitAst::Block(b) => {
                    format_list(
                        b.exprs,
                        ctx,
                        indent,
                        interner,
                        [TokenKind::LBrace, TokenKind::Semi, TokenKind::RBrace],
                        true,
                        b.trailing_semi,
                        format_expr,
                    );
                }
                UnitAst::Unary(u) => {
                    ctx.push_str(u.op.kind.name());
                    format_expr(u.expr, ctx, indent, interner);
                }
                UnitAst::Array(a) => {
                    format_list(
                        a,
                        ctx,
                        indent,
                        interner,
                        [TokenKind::LBracket, TokenKind::Comma, TokenKind::RBracket],
                        false,
                        false,
                        format_expr,
                    );
                }
                UnitAst::FilledArray(a) => {
                    ctx.push('[');
                    format_expr(a.expr, ctx, indent, interner);
                    ctx.push(';');
                    format_expr(a.len, ctx, indent, interner);
                    ctx.push(']');
                }
                UnitAst::Tuple(t) => {
                    format_list(
                        t,
                        ctx,
                        indent,
                        interner,
                        [TokenKind::Tuple, TokenKind::Comma, TokenKind::RParen],
                        false,
                        false,
                        format_expr,
                    );
                }
                UnitAst::Struct(s) => {
                    format_list(
                        s,
                        ctx,
                        indent,
                        interner,
                        [TokenKind::Struct, TokenKind::Comma, TokenKind::RBrace],
                        true,
                        true,
                        |field, ctx, indent, interner| match field {
                            StructField::Decl(named) => {
                                ctx.push_str(&interner[named.name.name]);
                                ctx.push_str(": ");
                                format_expr(named.expr, ctx, indent, interner);
                            }
                            StructField::Inline(name) => {
                                ctx.push_str(&interner[name.name]);
                            }
                            StructField::Embed(expr) => {
                             :{hello there}   ctx.push_str(TokenKind::DoubleDot.name());
                                format_expr(expr, ctx, indent, interner);
                            }
                        },
                    );
                }
                UnitAst::Index(i) => {
                    format_unit(i.expr, ctx, indent, interner);
                    ctx.push('[');
                    format_expr(i.index, ctx, indent, interner);
                    ctx.push(']');
                }
                UnitAst::Enum(e) => {
                    ctx.push_str(TokenKind::Enum.name());
                    match e.value {
                        Some(val) => {
                            ctx.push(' ');
                            ctx.push_str(&interner[e.name.name]);
                            ctx.push_str(": ");
                            format_expr(val, ctx, indent, interner);
                            ctx.push_str(" }");
                        }
                        None => {
                            ctx.push_str(&interner[e.name.name]);
                            ctx.push('}');
                        }
                    }
                }
                UnitAst::Call(c) => {
                    format_unit(c.callee, ctx, indent, interner);
                    format_list(
                        c.args,
                        ctx,
                        indent,
                        interner,
                        [TokenKind::LParen, TokenKind::Comma, TokenKind::RParen],
                        false,
                        false,
                        format_expr,
                    );
                }
                UnitAst::Func(f) => {
                    format_list(
                        f.args,
                        ctx,
                        indent,
                        interner,
                        [
                            TokenKind::Op(OpCode::BitOr),
                            TokenKind::Comma,
                            TokenKind::Op(OpCode::BitOr),
                        ],
                        false,
                        false,
                        |param, ctx, indent, interner| {
                            ctx.push_str(&interner[param.name.name]);
                            if let Some(default) = param.default {
                                ctx.push_str(": ");
                                format_unit(default, ctx, indent, interner);
                            }
                        },
                    );
                    ctx.push(' ');
                    format_expr(f.body, ctx, indent, interner);
                }
                UnitAst::Decl(d) => {
                    ctx.push_str(&interner[d.name.name]);
                    ctx.push_str(": ");
                    format_expr(d.expr, ctx, indent, interner);
                }
                UnitAst::Loop(l) => {
                    ctx.push_str(TokenKind::Loop.name());
                    if let Some(label) = l.label {
                        ctx.push('.');
                        ctx.push_str(&interner[label.name]);
                    }
                    ctx.push(' ');
                    format_expr(l.body, ctx, indent, interner);
                }
                UnitAst::ForLoop(fl) => {
                    ctx.push_str(TokenKind::For.name());
                    if let Some(label) = fl.label {
                        ctx.push('.');
                        ctx.push_str(&interner[label.name]);
                    }
                    ctx.push(' ');
                    ctx.push_str(&interner[fl.var.name]);
                    ctx.push(' ');
                    ctx.push_str(TokenKind::In.name());
                    ctx.push(' ');
                    format_expr(fl.iter, ctx, indent, interner);
                    ctx.push(' ');
                    format_expr(fl.body, ctx, indent, interner);
                }
                UnitAst::Break(_) => ::core::panicking::panic("not yet implemented"),
                UnitAst::Continue(_) => ::core::panicking::panic("not yet implemented"),
                UnitAst::FieldAccess(fa) => {
                    format_unit(fa.expr, ctx, indent, interner);
                    ctx.push('.');
                    ctx.push_str(&interner[fa.field.name]);
                :{hello there}
                UnitAst::If(i) => {
                    ctx.push_str(TokenKind::If.name());
                    ctx.push(' ');
                    format_expr(i.cond, ctx, indent, interner);
                    ctx.push(' ');
                    format_expr(i.then, ctx, indent, interner);
                    if let Some(else_) = i.else_ {
                        ctx.push(' ');
                        ctx.push_str(TokenKind::Else.name());
                        ctx.push(' ');
                        format_expr(else_, ctx, indent, interner);
                    }
                }
                UnitAst::Ret(r) => {
                    ctx.push_str(TokenKind::Ret.name());
                    if let Some(&expr) = r {
                        ctx.push(' ');
                        format_expr(expr, ctx, indent, interner);
                    }
                }
                UnitAst::Paren(&p) => {
                    format_expr(p, ctx, indent, interner);
                }
                UnitAst::Unknown(..) => ctx.push_str(TokenKind::Unknown.name()),
            }
        }
    }
    use crate::TokenKind::*;
    pub struct Parser<'ctx, 'src, 'arena> {
        files: &'src Files,
        next: Token<'src>,
        lexer: Lexer<'src>,
        interner: &'ctx StrInterner,
        diags: &'ctx mut Diagnostics,
        arena: &'arena ArenaScope<'ctx>,
        string_parser: &'ctx mut StringParser,
        imports: &'ctx mut Vec<IdentAst>,
    }
    impl<'ctx, 'src, 'arena> Parser<'ctx, 'src, 'arena> {
        pub fn new(
            files: &'src Files,
            file: FileRef,
            interner: &'ctx StrInterner,
            diags: &'ctx mut Diagnostics,
            arena: &'arena ArenaScope<'ctx>,
            string_parser: &'ctx mut StringParser,
            imports: &'ctx mut Vec<IdentAst>,
        ) -> Self {
            if !imports.is_empty() {
                ::core::panicking::panic("assertion failed: imports.is_empty()")
            };
            let mut lexer = Lexer::new(files, file);
            Self {
                files,
                next: lexer.next_tok(),
                lexer,
                interner,
                diags,
                arena,
                string_parser,
                imports,
            }
        }
        pub fn parse(&mut self, diver: Diver) -> Option<&'arena [ExprAst<'arena>]> {
            self.sequence(diver, Self::expr, Semi, Eof, "declaration")
                .map(|(decls, _)| &*decls)
        }
        fn sequence<T>(
            &mut self,
            mut diver: Diver,
            mut f: impl FnMut(&mut Self, Diver) -> Option<T>,
            sep: impl TokenPattern,
            end: impl TokenPattern,
            objective: impl Display,
        ) -> Option<(&'arena mut [T], bool)> {
            let mut elems = diver.dive::<T>();
            let trailing_sep = loop {
                if self.try_advance(end.clone()).is_some() {
                    break elems.len() > 0;
                }
                let elem = f(self, elems.untyped_dive())?;
                elems.push(elem);
                if self.try_advance(end.clone()).is_some() {
                    break false;
                }
                self.expect_advance(
                    sep.clone(),
                    format_args!("missing separateor in {0} list", objective),
                )?;
            };
            Some((self.arena.alloc_rev_iter(elems), trailing_sep))
        }
        fn try_advance(&mut self, pat: impl TokenPattern) -> Option<Token<'src>> {
            pat.matches(self.peek()).then(|| self.next())
        }
        fn expect_advance(
            &mut self,
            pat: impl TokenPattern,
            msg: impl Display,
        ) -> Option<Token<'sr:{hello there}c>> {
            self.try_advance(pat.clone()).or_else(|| {
                self.diags
                    .builder(self.files)
                    .annotation(
                        Error,
                        self.next.span,
                        format_args!("expected {0} but got {1}", pat.display(), self.next.kind),
                    )
                    .footer(Error, msg)
                    .terminate()?
            })
        }
        fn next(&mut self) -> Token<'src> {
            let tok = self.next;
            self.next = self.lexer.next_tok();
            tok
        }
        fn peek(&self) -> Token<'src> {
            self.next
        }
    }
    trait TokenPattern: Clone {
        fn matches(&self, tok: Token) -> bool;
        fn display(&self) -> impl Display + '_;
    }
    impl TokenPattern for TokenKind {
        fn matches(&self, tok: Token) -> bool {
            tok.kind == *self
        }
        fn display(&self) -> impl Display + '_ {
            self
        }
    }
    impl TokenPattern for &str {
        fn matches(&self, tok: Token) -> bool {
            tok.source == *self
        }
        fn display(&self) -> impl Display + '_ {
            self
        }
    }
    impl<T: TokenPattern, const N: usize> TokenPattern for [T; N] {
        fn matches(&self, tok: Token) -> bool {
            self.iter().any(|pat| pat.matches(tok))
        }
        fn display(&self) -> impl Display + '_ {
            self.iter()
                .map(TokenPattern::display)
                .fold(String::new(), |mut acc, pat| {
                    if !acc.is_empty() {
                        acc.push_str(" or ");
                    }
                    use std::fmt::Write;
                    acc.write_fmt(format_args!("{0}", pat)).unwrap();
                    acc
                })
        }
    }
    pub trait TransposeOpt {
        fn transpose(self) -> Self;
    }
    impl<T> TransposeOpt for Option<Option<T>> {
        fn transpose(self) -> Self {
            match self {
                Some(Some(x)) => Some(Some(x)),
                Some(None) => None,
                None => Some(None),
            }
        }
    }
    pub struct StringParser {
        buffer: String,
    }
    #[automatically_derived]
    impl ::core::default::Default for StringParser {
        #[inline]
        fn default() -> StringParser {
            StringParser {
                buffer: ::core::default::Default::default(),
            }
        }
    }
    pub enum StringParseError {
        InvalidEscape(usize),
        IncompleteEscape,
    }
    impl StringParser {
        pub fn parse(
            &mut self,
            source: &str,
            interner: &StrInterner,
        ) -> Result<InternedStr, StringParseError> {
            self.buffer.clear();
            let mut chars = source.char_indices();
            while let Some((_, c)) = chars.next() {
                match c {
                    '\\' => {
                        let (i, c) = chars.next().ok_or(StringParseError::IncompleteEscape)?;
                        match c {
                            'n' => self.bu:{hello there}ffer.push('\n'),
                            'r' => self.buffer.push('\r'),
                            't' => self.buffer.push('\t'),
                            '\\' => self.buffer.push('\\'),
                            '"' => self.buffer.push('"'),
                            '\'' => self.buffer.push('\''),
                            '0' => self.buffer.push('\0'),
                            _ => return Result::Err(StringParseError::InvalidEscape(i)),
                        }
                    }
                    _ => self.buffer.push(c),
                }
            }
            Ok(interner.intern(&self.buffer))
        }
    }
}
mod source {
    use std::{
        iter,
        path::{Path, PathBuf},
    };
    pub struct Files {
        files: Vec<Option<File>>,
        free: Vec<FileRef>,
    }
    #[automatically_derived]
    impl ::core::default::Default for Files {
        #[inline]
        fn default() -> Files {
            Files {
                files: ::core::default::Default::default(),
                free: ::core::default::Default::default(),
            }
        }
    }
    impl Files {
        pub fn new() -> Self {
            Self {
                files: Vec::new(),
                free: Vec::new(),
            }
        }
        pub fn add_file(&mut self, file: File) -> (FileRef, &mut File) {
            let index = self.free.pop().unwrap_or_else(|| {
                let index = self.files.len();
                self.files.push(None);
                FileRef::new(index)
            });
            let moved = self.files[index.0 as usize].insert(file);
            (index, moved)
        }
        pub fn get_file(&self, file: FileRef) -> &File {
            self.files[file.0 as usize]
                .as_ref()
                .expect("file has been removed")
        }
        pub fn remove_file(&mut self, file: FileRef) -> File {
            self.files[file.0 as usize]
                .take()
                .expect("file has already been removed")
        }
    }
    pub struct FileRef(u16);
    #[automatically_derived]
    impl ::core::clone::Clone for FileRef {
        #[inline]
        fn clone(&self) -> FileRef {
            let _: ::core::clone::AssertParamIsClone<u16>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for FileRef {}
    #[automatically_derived]
    impl ::core::fmt::Debug for FileRef {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "FileRef", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FileRef {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FileRef {
        #[inline]
        fn eq(&self, other: &FileRef) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for FileRef {}
    #[automatically_derived]
    impl ::core::cmp::Eq for FileRef {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u16>;
        }
    }
    #[automatically_derived:{hello there}]
    impl ::core::hash::Hash for FileRef {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for FileRef {
        #[inline]
        fn partial_cmp(&self, other: &FileRef) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for FileRef {
        #[inline]
        fn cmp(&self, other: &FileRef) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    impl FileRef {
        fn new(index: usize) -> Self {
            Self(
                index
                    .try_into()
                    .expect("amount of source files cannot exceed 65535"),
            )
        }
    }
    pub struct File {
        name: PathBuf,
        source: String,
        modification_id: u64,
    }
    impl File {
        pub fn new(name: PathBuf, source: String) -> Self {
            Self::with_modification_id(name, source, 0)
        }
        pub fn with_modification_id(name: PathBuf, source: String, modification_id: u64) -> Self {
            let nline_offsets = iter::once(0)
                .chain(source.match_indices('\n').map(|(i, ..)| i as u16))
                .collect::<Vec<_>>();
            if !(nline_offsets.len() <= u16::MAX as usize) {
                {
                    ::core::panicking::panic_fmt(format_args!(
                        "amount of lines in file cannot exceed 65535"
                    ));
                }
            };
            Self {
                name,
                source,
                modification_id,
            }
        }
        pub fn name(&self) -> &Path {
            &self.name
        }
        pub fn source(&self) -> &str {
            &self.source
        }
        pub fn modification_id(&self) -> u64 {
            self.modification_id
        }
        pub fn update(&mut self, source: String, modification_id: u64) {
            self.source = source;
            self.modification_id = modification_id;
        }
    }
    pub struct Span {
        row: u16,
        col: u16,
        file: FileRef,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Span {
        #[inline]
        fn clone(&self) -> Span {
            let _: ::core::clone::AssertParamIsClone<u16>;
            let _: ::core::clone::AssertParamIsClone<FileRef>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Span {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Span {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Span",
                "row",
                &self.row,
                "col",
                &self.col,
                "file",
                &&self.file,
            )
        }
    }
    #[automatically_derived:{hello there}]
    impl ::core::marker::StructuralPartialEq for Span {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Span {
        #[inline]
        fn eq(&self, other: &Span) -> bool {
            self.row == other.row && self.col == other.col && self.file == other.file
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Span {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Span {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u16>;
            let _: ::core::cmp::AssertParamIsEq<FileRef>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Span {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.row, state);
            ::core::hash::Hash::hash(&self.col, state);
            ::core::hash::Hash::hash(&self.file, state)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Span {
        #[inline]
        fn partial_cmp(&self, other: &Span) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.row, &other.row) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(&self.col, &other.col) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(&self.file, &other.file)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Span {
        #[inline]
        fn cmp(&self, other: &Span) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.row, &other.row) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.col, &other.col) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(&self.file, &other.file)
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    impl Span {
        pub(crate) fn new(row: usize, col: usize, file_ref: FileRef) -> Self {
            Self {
                row: row as u16,
                col: col as u16,
                file: file_ref,
            }
        }
        pub fn file(&self) -> FileRef {
            self.file
        }
        pub fn row(&self) -> usize {
            self.row as usize
        }
        pub fn col(&self) -> usize {
            self.col as usize
        }
        pub(crate) fn shift(&self, index: usize) -> Span {
            Span {
                row: self.row,
                col: self.col + index as u16,
                file: self.file,
            }
        }
    }
}
mod temp_mem {
    use std::{cell::UnsafeCell, iter::TrustedLen};
    use mini_alloc::{ArenaBase, ArenaScope, Diver, DiverBase};
    pub struct TempMemBase {
        arena: ArenaBase,
        diver: DiverBase,
    }
    #[automatically_derived]
    impl ::core::default::Default for TempMemBase {
        #[inline]
        fn default() -> TempMemBase {
            TempMemBase :{hello there}{
                arena: ::core::default::Default::default(),
                diver: ::core::default::Default::default(),
            }
        }
    }
    impl TempMemBase {
        pub fn new() -> Self {
            Self::default()
        }
        pub fn scope(&mut self) -> TempMem {
            TempMem {
                arena: self.arena.scope(),
                diver: self.diver.untyped_dive().into(),
            }
        }
        pub fn diver_and_arena(&mut self) -> (Diver, ArenaScope) {
            let arena = self.arena.scope();
            let diver = self.diver.untyped_dive();
            (diver, arena)
        }
    }
    pub struct TempMem<'a> {
        arena: ArenaScope<'a>,
        diver: UnsafeCell<Diver<'a>>,
    }
    impl<'a> TempMem<'a> {
        pub fn collect_trusted_len<I>(&self, iter: I) -> &mut [I::Item]
        where
            I: IntoIterator,
            I::IntoIter: ExactSizeIterator + TrustedLen,
            I::Item: Copy,
        {
            self.arena.alloc_iter(iter)
        }
        pub fn collect<I>(&self, iter: I) -> &mut [I::Item]
        where
            I: IntoIterator,
            I::Item: Copy,
        {
            let mut dive = unsafe { (*self.diver.get()).dive::<I::Item>() };
            dive.extend(iter);
            self.arena.alloc_rev_iter(dive)
        }
    }
}
mod types {
    use mini_alloc::{Interned, InternedSlice, InternedStr, Interner};
    pub struct NameSet(InternedSlice<InternedStr>);
    pub struct Types {
        names: Interner<InternedStr>,
        types: Interner<Type>,
    }
    #[automatically_derived]
    impl ::core::default::Default for Types {
        #[inline]
        fn default() -> Types {
            Types {
                names: ::core::default::Default::default(),
                types: ::core::default::Default::default(),
            }
        }
    }
    impl Types {
        pub fn new() -> Self {
            Self::default()
        }
        pub fn intern_enum(&self, variants: &mut [(InternedStr, Type)]) -> EnumType {
            let (names, types) = self.intern_type_set(variants);
            EnumType { names, types }
        }
        pub fn intern_struct(&self, fields: &mut [(InternedStr, Type)]) -> StructType {
            let (names, types) = self.intern_type_set(fields);
            StructType { names, types }
        }
        pub fn create_name_set(&self, names: &mut [InternedStr]) -> NameSet {
            names.sort_unstable();
            let names = self.names.intern_slice(&*names);
            NameSet(names)
        }
        fn intern_type_set(
            &self,
            elems: &mut [(InternedStr, Type)],
        ) -> (InternedSlice<InternedStr>, InternedSlice<Type>) {
            elems.sort_unstable_by(|(a, _), (b, _)| a.cmp(b));
            let names = self.names.intern_iter(elems.iter().map(|&(name, _)| name));
            let types = self.types.intern_iter(elems.iter().map(|&(_, ty)| ty));
            (names, types)
        }
        pub fn intern_func(&self, args: &[Type], ret: Type) -> FuncType {
            let args = self.types.intern_slice(args);
            let ret = self.types.intern(ret);
            FuncType { args, ret }
        }
        pub fn intern_array(&self, ty: Type, len: u32) -> ArrayType {
            let ty = self.types.intern(ty);
            ArrayType { ty, len }
        }
    }
    pub struct Unknowns {
        slots: Vec<Option<Type>>:{hello there},
    }
    #[automatically_derived]
    impl ::core::default::Default for Unknowns {
        #[inline]
        fn default() -> Unknowns {
            Unknowns {
                slots: ::core::default::Default::default(),
            }
        }
    }
    impl Unknowns {
        pub fn new() -> Self {
            Self::default()
        }
        pub fn next(&mut self) -> UnknownType {
            let id = self.slots.len() as u32;
            self.slots.push(None);
            UnknownType(id)
        }
        pub fn set(&mut self, id: UnknownType, ty: Type) -> Option<Type> {
            self.slots[id.0 as usize].replace(ty)
        }
    }
    pub enum Type {
        Builtin(BuiltinType),
        Struct(StructType),
        Enum(EnumType),
        Array(ArrayType),
        Func(FuncType),
        Module(InternedStr),
        Unknown(UnknownType),
        Type,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Type {}
    #[automatically_derived]
    impl ::core::clone::Clone for Type {
        #[inline]
        fn clone(&self) -> Type {
            let _: ::core::clone::AssertParamIsClone<BuiltinType>;
            let _: ::core::clone::AssertParamIsClone<StructType>;
            let _: ::core::clone::AssertParamIsClone<EnumType>;
            let _: ::core::clone::AssertParamIsClone<ArrayType>;
            let _: ::core::clone::AssertParamIsClone<FuncType>;
            let _: ::core::clone::AssertParamIsClone<InternedStr>;
            let _: ::core::clone::AssertParamIsClone<UnknownType>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Type {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Type {
        #[inline]
        fn eq(&self, other: &Type) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (Type::Builtin(__self_0), Type::Builtin(__arg1_0)) => *__self_0 == *__arg1_0,
                    (Type::Struct(__self_0), Type::Struct(__arg1_0)) => *__self_0 == *__arg1_0,
                    (Type::Enum(__self_0), Type::Enum(__arg1_0)) => *__self_0 == *__arg1_0,
                    (Type::Array(__self_0), Type::Array(__arg1_0)) => *__self_0 == *__arg1_0,
                    (Type::Func(__self_0), Type::Func(__arg1_0)) => *__self_0 == *__arg1_0,
                    (Type::Module(__self_0), Type::Module(__arg1_0)) => *__self_0 == *__arg1_0,
                    (Type::Unknown(__self_0), Type::Unknown(__arg1_0)) => *__self_0 == *__arg1_0,
                    _ => true,
                }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Type {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Type {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<BuiltinType>;
            let _: ::core::cmp::AssertParamIsEq<StructType>;
            let _: ::core::cmp::AssertParamIsEq<EnumType>;
            let _: ::core::cmp::AssertParamIsEq<ArrayType>;
            let _: ::core::cmp::AssertParamIsEq<FuncType>;
            let _: ::core::cmp::AssertParamIsEq<InternedStr>;
            let _: ::core::cmp::AssertParamIsEq<UnknownType>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Type {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state);
            match self {
                Type::Builtin(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Type::Struct(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Type::Enum(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Type::Array(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Type::Func(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Type::Module(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                Type::Unknown(__self_0) => :::{hello there}core::hash::Hash::hash(__self_0, state),
                _ => {}
            }
        }
    }
    pub struct UnknownType(u32);
    #[automatically_derived]
    impl ::core::marker::Copy for UnknownType {}
    #[automatically_derived]
    impl ::core::clone::Clone for UnknownType {
        #[inline]
        fn clone(&self) -> UnknownType {
            let _: ::core::clone::AssertParamIsClone<u32>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UnknownType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UnknownType {
        #[inline]
        fn eq(&self, other: &UnknownType) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for UnknownType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for UnknownType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u32>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for UnknownType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    pub enum BuiltinType {
        Int,
        Float,
        Bool,
        Char,
        Str,
        Unit,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for BuiltinType {}
    #[automatically_derived]
    impl ::core::clone::Clone for BuiltinType {
        #[inline]
        fn clone(&self) -> BuiltinType {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for BuiltinType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for BuiltinType {
        #[inline]
        fn eq(&self, other: &BuiltinType) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for BuiltinType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for BuiltinType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for BuiltinType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    pub struct StructType {
        names: InternedSlice<InternedStr>,
        types: InternedSlice<Type>,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for StructType {}
    #[automatically_derived]
    impl ::core::clone::Clone for StructType {
        #[inline]
        fn clone(&self) -> StructType {
            let _: ::core::clone::AssertParamIsClone<InternedSlice<InternedStr>>;
            let _: ::core::clone::AssertParamIsClone<InternedSlice<Type>>;
            *self
        }
    :{hello there}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for StructType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for StructType {
        #[inline]
        fn eq(&self, other: &StructType) -> bool {
            self.names == other.names && self.types == other.types
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for StructType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for StructType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<InternedSlice<InternedStr>>;
            let _: ::core::cmp::AssertParamIsEq<InternedSlice<Type>>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for StructType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.names, state);
            ::core::hash::Hash::hash(&self.types, state)
        }
    }
    impl StructType {
        pub fn names(self, types: &Types) -> &[InternedStr] {
            &types.names[self.names]
        }
        pub fn types(self, types: &Types) -> &[Type] {
            &types.types[self.types]
        }
    }
    pub type EnumType = StructType;
    pub struct ArrayType {
        ty: Interned<Type>,
        len: u32,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ArrayType {}
    #[automatically_derived]
    impl ::core::clone::Clone for ArrayType {
        #[inline]
        fn clone(&self) -> ArrayType {
            let _: ::core::clone::AssertParamIsClone<Interned<Type>>;
            let _: ::core::clone::AssertParamIsClone<u32>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ArrayType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ArrayType {
        #[inline]
        fn eq(&self, other: &ArrayType) -> bool {
            self.ty == other.ty && self.len == other.len
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for ArrayType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ArrayType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Interned<Type>>;
            let _: ::core::cmp::AssertParamIsEq<u32>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ArrayType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.ty, state);
            ::core::hash::Hash::hash(&self.len, state)
        }
    }
    impl ArrayType {
        pub fn ty(self, types: &Types) -> Type {
            types.types[self.ty]
        }
        pub fn len(self) -> u32 {
            self.len
        }
    }
    pub struct FuncType {
        args: InternedSlice<Type>,
        ret: Interned<Type>,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for FuncType {}
    #[automatically_derived]
    impl ::core::clone::Clone for FuncType {
        #[inline]
        fn clone(&self) -> FuncType {
            let _: ::core::clone::AssertParamIsClone<InternedSlice<Type>>;
            let _:{hello there}: ::core::clone::AssertParamIsClone<Interned<Type>>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FuncType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FuncType {
        #[inline]
        fn eq(&self, other: &FuncType) -> bool {
            self.args == other.args && self.ret == other.ret
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for FuncType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for FuncType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<InternedSlice<Type>>;
            let _: ::core::cmp::AssertParamIsEq<Interned<Type>>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for FuncType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.args, state);
            ::core::hash::Hash::hash(&self.ret, state)
        }
    }
    impl FuncType {
        pub fn args(self, types: &Types) -> &[Type] {
            &types.types[self.args]
        }
        pub fn ret(self, types: &Types) -> Type {
            types.types[self.ret]
        }
    }
}
pub use {
    cache::{
        scope::{Scope, ScopeCache, ScopeFrame, ScopeRange, ScopeView, Sym},
        storage::{
            CachePool, CacheRef, CacheSlice, CacheVec, CacheVecPush, CacheVecRange, CacheVecView,
        },
        Cache, CacheLoader, CachePush, CacheRange, CacheView, Loader, Module, Modules,
    },
    diagnostics::{Diagnostic, DiagnosticConfig, Diagnostics, Severty},
    lexer::{Lexer, OpCode, Token, TokenKind},
    parser::{
        expr::{
            BinaryAst, BlockAst, BreakAst, CallAst, ContinueAst, EnumAst, ExprAst, FieldAccessAst,
            FilledArrayAst, ForLoopAst, FuncArgAst, FuncAst, IdentAst, IfAst, LiteralAst,
            LiteralKindAst, LoopAst, OpAst, StructField, UnaryAst, UnitAst,
        },
        fmt::format_ast,
        Parser, StringParseError, StringParser, TransposeOpt,
    },
    source::{File, FileRef, Files, Span},
    temp_mem::{TempMem, TempMemBase},
    types::{
        ArrayType, BuiltinType, EnumType, FuncType, StructType, Type, Types, UnknownType, Unknowns,
    },
}:{hello there};
