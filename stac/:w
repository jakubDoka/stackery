use std::ops::Index;

use mini_alloc::*;

use crate::*;

#[derive(Default)]
struct InstrEmiterRes {
    used_consts: FnvHashMap<LiteralKindAst, Const>,
    used_idents: FnvHashMap<InternedStr, Ident>,
    decl_scope: Scope<SymData>,
    loop_scope: Scope<LoopData>,
    breaks: Vec<BreakData>,
    modules: Vec<(InternedStr, ModuleRef)>,
    string_parser: StringParser,
}

struct BreakData {
    addr: Ref<Instr, InstrIndex>,
    label: Loop,
}

impl InstrEmiterRes {
    fn prepare_for_function(&mut self) {
        self.used_consts.clear();
        self.used_idents.clear();
        assert!(self.loop_scope.is_empty());
    }
}

impl<'a> InstrEmiter<'a> {
    pub fn emmit(mut self, temp_mem: &mut TempMemBase) -> Option<()> {
        let mut res = InstrEmiterRes::default();

        self.clean_meta();
        self.parse_modules(&mut res, temp_mem);

        Some(())
    }

    fn clean_meta(&mut self) {
        let preserved_modules = self.modules.preserved();
        let mut preserved_modules = self
            .instrs
            .modules
            .multiple_mut(preserved_modules)
            .map(|module| &mut module.meta)
            .collect::<Vec<_>>();

        self.instrs
            .module_meta
            .preserve_ranges(preserved_modules.as_mut_slice());

        let mut funcs = self
            .instrs
            .module_meta
            .funcs
            .values_mut()
            .map(|func| &mut func.meta)
            .collect::<Vec<_>>();

        self.instrs.func_meta.preserve_ranges(funcs.as_mut_slice());
    }

    fn parse_modules(&mut self, res: &mut InstrEmiterRes, temp_mem: &mut TempMemBase) {
        for module in self.modules.changed() {
            let (diver, arena) = temp_mem.diver_and_arena();
            let Some(ast) = Parser::new(
                self.modules.files(),
                self.modules.module_file(module),
                self.interner,
                self.diags,
                &arena,
                &mut res.string_parser,
            ).parse(diver) else {
                continue;
            };

            res.modules.clear();
            res.modules.extend(self.modules.deps_of(module));

            let meta = self.emmit_module(ast, res);
            self.instrs.modules[module] = InstrModule { meta };
        }
    }

    fn emmit_module<'arena>(
        &mut self,
        items: &[ExprAst<'arena>],
        res: &mut InstrEmiterRes,
    ) -> InstrModuleMetaSlice {
        let mut module_meta = self.instrs.module_meta.builder();

        let mut func_stack = Self::collect_module_items(
            self.modules.files(),
            self.interner,
            self.diags,
            items,
            res,
            &mut module_meta,
        );
        let frame = Self::prepare_scope(
            self.modules.files(),
            self.interner,
            self.diags,
            res,
            &mut module_meta,
        );

        while let Some((func_ref, func)) = func_stack.pop() {
            res.prepare_for_function();
            FuncBuilder {
                inner: self.instrs.func_meta.builder(),
                entities: &mut module_meta,
                modules: self.modules,
                interner: self.interner,
                diags: self.diags,
                res,
                func_stack: &mut func_stack,
            }
            .build_func(func, func_ref);
        }

        res.decl_scope.end_frame(frame);

        module_meta.finish()
    }

    fn prepare_scope(
        files: &Files,
        interner: &StrInterner,
        diags: &mut Diagnostics,
        res: &mut InstrEmiterRes,
        entities: &mut InstrModuleMetaBuilder,
    ) -> ScopeFrame {
        let frame = res.decl_scope.start_frame();

        entities.items.sort_unstable_by_key(|item| item.name);

        for group in entities
            .items
            .group_by(|a, b| a.name == b.name)
            .filter(|g| g.len() > 1)
        {
            let mut builder = diags
                .builder(files, interner)
                .footer(Severty::Error, "duplicate declaration")
                .footer(Severty::Note, "module use name only once");

            for item in group {
                builder =
                    builder.annotation(Severty::Error, item.span, "found duplicate declaration");
            }
        }

        for &item in entities.items.iter() {
            res.decl_scope.push(instrs::SymData(item.name));
        }

        frame
    }

    fn collect_module_items<'arena>(
        files: &Files,
        interner: &StrInterner,
        diags: &mut Diagnostics,
        items: &[ExprAst<'arena>],
        res: &mut InstrEmiterRes,
        entities: &mut InstrModuleMetaBuilder,
    ) -> Vec<(FuncRef, FuncAst<'arena>)> {
        let mut funcs = Vec::with_capacity(items.len());
        for &item in items {
            let NamedExprAst { name, expr } = match item {
                ExprAst::Unit(UnitAst::Decl(&n)) => n,
                expr => {
                    diags
                        .builder(files, interner)
                        .footer(Severty::Error, "expected declaration as top level item")
                        .annotation(Severty::Error, expr.span(), "found expression");
                    continue;
                }
            };

            let kind = match expr {
                ExprAst::Unit(UnitAst::Func(&func)) => {
                    let func_ref = entities.funcs.push(Func::default());

                    funcs.push((func_ref, func));
                    InstrItemKind::Func(func_ref)
                }
                ExprAst::Unit(UnitAst::Import(module)) => {
                    let Some(module) = res.modules.iter().find_map(|&(name, id)| (name == module.ident).then_some(id)) else {
                        diags
                            .builder(files, interner)
                            .footer(Severty::Error, "module not found")
                            .annotation(Severty::Error, module.span, "requested here");
                        continue;
                    };

                    InstrItemKind::Import(module)
                }
                expr => {
                    diags
                        .builder(files, interner)
                        .footer(Severty::Error, "expected function as top level item")
                        .footer(Severty::Note, "static values are not yet supported")
                        .annotation(Severty::Error, expr.span(), "found expression");
                    continue;
                }
            };

            entities.items.push(InstrItem {
                name: name.ident,
                kind,
                span: name.span,
            });
        }
        funcs
    }
}

struct FuncBuilder<'a, 'arena, 'ctx> {
    inner: FuncMetaBuilder<'a>,
    entities: &'a mut InstrModuleMetaBuilder<'ctx>,
    modules: &'a Modules,
    interner: &'a StrInterner,
    diags: &'a mut Diagnostics,
    res: &'a mut InstrEmiterRes,
    func_stack: &'a mut Vec<(FuncRef, FuncAst<'arena>)>,
}

impl<'a, 'arena, 'ctx> FuncBuilder<'a, 'arena, 'ctx> {
    fn build_func(mut self, FuncAst { args, body, .. }: FuncAst<'arena>, into: FuncRef) {
        let scope = self.res.decl_scope.start_frame();

        for arg in args {
            self.res.decl_scope.push(instrs::SymData(arg.name.ident));
        }

        self.expr(body);

        self.res.decl_scope.end_frame(scope);

        let func = &mut self.entities.funcs[into];

        func.meta = self.inner.finish();
        func.arg_count = args.len().try_into().unwrap();
    }

    fn expr(&mut self, expr: ExprAst<'arena>) {
        match expr {
            ExprAst::Unit(u) => self.unit(u),
            ExprAst::Binary(&b) => self.binary(b),
        }
    }

    fn unit(&mut self, unit: UnitAst<'arena>) {
        match unit {
            UnitAst::Literal(l) => self.literal(l),
            UnitAst::Ident(i) => self.ident(i),
            UnitAst::Import(i) => self.import(i),
            UnitAst::Block(&b) => self.block(b),
            UnitAst::Unary(&u) => self.unary(u),
            UnitAst::Array { bracket, elems } => self.array(bracket, elems),
            UnitAst::FilledArray(&fa) => self.filled_array(fa),
            UnitAst::Tuple { keyword, values } => self.tuple(keyword, values),
            UnitAst::Struct { keyword, fields } => self.struct_(keyword, fields),
            UnitAst::Enum(&e) => self.enum_(e),
            UnitAst::Call(&c) => self.call(c),
            UnitAst::Func(&f) => self.func(f),
            UnitAst::Decl(&d) => self.decl(d),
            UnitAst::Loop(&l) => self.loop_(l),
            UnitAst::Index(&i) => self.index(i),
            UnitAst::ForLoop(..) => todo!(),
            UnitAst::Break(&b) => self.break_(b),
            UnitAst::Continue(c) => self.continue_(c),
            UnitAst::Field(&f) => self.field(f),
            UnitAst::If(&i) => self.if_(i),
            UnitAst::Ret { value, .. } => self.ret(value.copied()),
            UnitAst::Paren(p) => self.expr(*p),
            UnitAst::Unknown(u) => self.unknown(u),
        }
    }

    fn literal(&mut self, LiteralAst { kind, .. }: LiteralAst) {
        let &mut lit = self
            .res
            .used_consts
            .entry(kind)
            .or_insert_with(|| self.inner.consts.push(kind));

        self.add_instr(Instr::Const(lit));
    }

    fn ident(&mut self, IdentAst { ident, span }: IdentAst) {
        let instr = match self.res.decl_scope.resolve(ident) {
            Some(sym) => Instr::Sym(sym),
            None => {
                self.diags
                    .builder(self.modules.files(), self.interner)
                    .footer(Severty::Error, "symbol not found")
                    .annotation(Severty::Error, span, "requested here");
                Instr::Error
            }
        };

        self.add_instr(instr);
    }

    fn import(&mut self, IdentAst { ident, span }: IdentAst) {
        let module = self
            .res
            .modules
            .iter()
            .find_map(|&(name, module)| (name == ident).then_some(module));
        let instr = match module {
            Some(instr) => Instr::Mod(instr),
            None => {
                self.diags
                    .builder(self.modules.files(), self.interner)
                    .footer(Severty::Error, "module not found")
                    .annotation(Severty::Error, span, "requested here");
                Instr::Error
            }
        };

        self.add_instr(instr);
    }

    fn block(
        &mut self,
        BlockAst {
            exprs,
            trailing_semi,
            ..
        }: BlockAst<'arena>,
    ) {
        let scope = self.res.decl_scope.start_frame();

        self.expr_list(exprs);
        let expr_count = exprs.len().try_into().unwrap();
        self.add_instr(Instr::Block {
            expr_count,
            returns: !trailing_semi,
        });

        self.res.decl_scope.end_frame(scope);
    }

    fn unary(&mut self, UnaryAst { op, expr }: UnaryAst<'arena>) {
        self.unit(expr);
        self.add_instr(Instr::Unary(op.kind));
    }

    fn array(&mut self, _bracket: Span, elems: &[ExprAst<'arena>]) {
        let item_count = elems.len().try_into().unwrap();
        self.add_instr(Instr::Array { item_count });

        self.expr_list(elems);
    }

    fn filled_array(&mut self, FilledArrayAst { expr, len, .. }: FilledArrayAst<'arena>) {
        self.expr(expr);
        self.expr(len);
        self.add_instr(Instr::FilledArray);
    }

    fn tuple(&mut self, _keyword: Span, values: &[ExprAst<'arena>]) {
        let item_count = values.len().try_into().unwrap();
        self.add_instr(Instr::Tuple { item_count });

        self.expr_list(values);
    }

    fn struct_(&mut self, _keyword: Span, fields: &[StructFieldAst<'arena>]) {
        let field_count = fields.len().try_into().unwrap();
        self.add_instr(Instr::Struct { field_count });

        for &field in fields {
            self.sturct_field(field);
        }
    }

    fn sturct_field(&mut self, field: StructFieldAst<'arena>) {
        let instr = match field {
            StructFieldAst::Decl(NamedExprAst { name, expr }) => {
                self.expr(expr);
                let name = self.intern_ident(name.ident);
                Instr::StructField {
                    name,
                    has_value: true,
                }
            }
            StructFieldAst::Inline(name) => {
                let name = self.intern_ident(name.ident);
                Instr::StructField {
                    name,
                    has_value: false,
                }
            }
            StructFieldAst::Embed(expr) => {
                self.expr(expr);
                Instr::Embed
            }
        };

        self.add_instr(instr);
    }

    fn enum_(&mut self, EnumAst { name, value }: EnumAst<'arena>) {
        if let Some(value) = value {
            self.expr(value);
        }
        let name = self.intern_ident(name.ident);
        self.add_instr(Instr::Enum {
            name,
            has_value: value.is_some(),
        });
    }

    fn call(&mut self, CallAst { caller, args }: CallAst<'arena>) {
        self.unit(caller);
        self.expr_list(args);
        let arg_count = args.len().try_into().unwrap();
        self.add_instr(Instr::Call { arg_count });
    }

    fn func(&mut self, func: FuncAst<'arena>) {
        let func_ref = self.entities.funcs.push(Default::default());
        self.func_stack.push((func_ref, func));
        self.add_instr(Instr::Func(func_ref));
    }

    fn decl(&mut self, NamedExprAst { name, expr }: NamedExprAst<'arena>) {
        self.res.decl_scope.push(instrs::SymData(name.ident));
        self.expr(expr);
        self.add_instr(Instr::Decl);
    }

    fn loop_(&mut self, LoopAst { label, body, .. }: LoopAst<'arena>) {
        let label = label.map(|label| label.ident).unwrap_or_default();

        let scope = self.res.loop_scope.start_frame();
        let offset = self.current_offset();
        let break_frame = self.res.breaks.len();
        self.res.loop_scope.push(LoopData {
            label,
            offset,
            break_frame,
        });

        self.expr(body);

        self.add_instr(Instr::Jump {
            to: offset,
            conditional: false,
        });

        let offset = self.current_offset();

        for break_data in self.res.breaks.drain(break_frame..) {
            self.inner.instrs[break_data.addr] = Instr::Jump {
                to: offset,
                conditional: false,
            };
        }

        self.res.loop_scope.end_frame(scope);
    }

    fn index(&mut self, IndexAst { expr, index }: IndexAst<'arena>) {
        self.unit(expr);
        self.expr(index);
        self.add_instr(Instr::Index);
    }

    fn break_(
        &mut self,
        BreakAst {
            label,
            expr,
            keyword,
        }: BreakAst<'arena>,
    ) {
        let Some(label) = self.find_loop(label, keyword) else {
            return;
        };

        if let Some(expr) = expr {
            self.expr(expr);
        }

        let addr = self.add_instr(Instr::Error);
        self.res.breaks.push(BreakData { addr, label });
    }

    fn continue_(&mut self, ContinueAst { label, keyword }: ContinueAst) {
        let Some(label) = self.find_loop(label, keyword) else {
            return;
        };

        self.add_instr(Instr::Continue(label));
    }

    fn find_loop(&mut self, label: Option<IdentAst>, keyword: Span) -> Option<Loop> {
        let label = label.map(|label| label.ident).unwrap_or_default();
        let res = self.res.loop_scope.resolve(label);

        if res.is_none() {
            self.diags
                .builder(self.modules.files(), self.interner)
                .footer(Severty::Error, "control flow does not have a matching loop")
                .annotation(Severty::Error, keyword, "this");
            self.add_instr(Instr::Error);
        }

        res
    }

    fn field(
        &mut self,
        FieldAst {
            expr,
            name: FieldIdentAst { ident, is_meta, .. },
        }: FieldAst<'arena>,
    ) {
        self.unit(expr);
        let name = self.intern_ident(ident);
        if is_meta {
            self.add_instr(Instr::MetaField(name));
        } else {
            self.add_instr(Instr::Field(name));
        }
    }

    fn if_(
        &mut self,
        IfAst {
            cond, then, else_, ..
        }: IfAst<'arena>,
    ) {
        self.expr(cond);
        let if_ = self.add_instr(Instr::Unkown);

        let current_len = self.inner.instrs.len();
        self.expr(then);
        let mut then = self.inner.instrs.len() - current_len;

        if let Some(else_) = else_ {
            let else_instr = self.add_instr(Instr::Unkown);

            let current_len = self.inner.instrs.len();
            self.expr(else_);
            self.inner.instrs[else_instr] = Instr::Else {
                instr_count: (self.inner.instrs.len() - current_len).try_into().unwrap(),
            };

            then += 1;
        }

        self.inner.instrs[if_] = Instr::If {
            instr_count: then.try_into().unwrap(),
        };
    }

    fn ret(&mut self, expr: Option<ExprAst<'arena>>) {
        if let Some(expr) = expr {
            self.expr(expr);
        }
        self.add_instr(Instr::Ret {
            has_value: expr.is_some(),
        });
    }

    fn unknown(&mut self, _: Span) {
        self.add_instr(Instr::Unkown);
    }

    fn expr_list(&mut self, exprs: &[ExprAst<'arena>]) {
        for &expr in exprs {
            self.expr(expr);
        }
    }

    fn binary(&mut self, BinaryAst { op, lhs, rhs }: BinaryAst<'arena>) {
        self.expr(lhs);
        self.expr(rhs);
        self.add_instr(Instr::Binary(op.kind));
    }

    fn intern_ident(&mut self, ident: InternedStr) -> Ident {
        *self
            .res
            .used_idents
            .entry(ident)
            .or_insert_with(|| self.inner.idents.push(ident))
    }

    fn current_offset(&self) -> InstrIndex {
        self.inner
            .instrs
            .len()
            .try_into()
            .expect("too many instructions")
    }

    fn add_instr(&mut self, instr: Instr) -> Ref<Instr, InstrIndex> {
        self.add_instr(instr)
    }
}

struct Scope<T> {
    vec: VecStore<T, InstrIndex>,
}

impl<T> Default for Scope<T> {
    fn default() -> Self {
        Self {
            vec: VecStore::default(),
        }
    }
}

impl<T> Scope<T> {
    fn push(&mut self, sym: T) -> Ref<T, InstrIndex> {
        self.vec.push(sym)
    }

    fn resolve(&self, name: T::Key) -> Option<Ref<T, InstrIndex>>
    where
        T: ScopeItem,
    {
        self.vec
            .iter()
            .rev()
            .find_map(|(id, sym)| (sym.key() == name).then_some(id))
    }

    fn start_frame(&self) -> ScopeFrame {
        ScopeFrame(self.vec.len())
    }

    fn end_frame(&mut self, frame: ScopeFrame) {
        self.vec.truncate(frame.0);
    }

    fn is_empty(&self) -> bool {
        self.vec.is_empty()
    }
}

impl<T> Index<Ref<T, InstrIndex>> for Scope<T> {
    type Output = T;

    fn index(&self, index: Ref<T, InstrIndex>) -> &Self::Output {
        &self.vec[index]
    }
}

struct ScopeFrame(usize);

trait ScopeItem {
    type Key: Eq + Copy;
    fn key(&self) -> Self::Key;
}

impl ScopeItem for LoopData {
    type Key = InternedStr;

    fn key(&self) -> Self::Key {
        self.label
    }
}

impl ScopeItem for SymData {
    type Key = InternedStr;

    fn key(&self) -> Self::Key {
        self.0
    }
}

#[cfg(test)]
mod test {
    use mini_alloc::*;
    use pollster::FutureExt;

    use crate::*;

    fn perform_test(sources: &str, ctx: &mut String) {
        let mut loader = LoaderMock::new(sources);

        let mut diagnostics = Diagnostics::default();
        let mut modules = Modules::default();
        let interner = StrInterner::default();

        let root = interner.intern("root");

        let meta = ModuleLoader::new(&mut loader, &mut modules, &interner, &mut diagnostics)
            .update(root)
            .block_on();

        if !diagnostics.diagnostic_view().is_empty() {
            ctx.push_str("loader diagnostics:\n");
            ctx.push_str(diagnostics.diagnostic_view());
            diagnostics.clear();
        }

        let Some(_meta) = meta else {
            ctx.push_str("no meta");
            return;
        };

        let mut instrs = Instrs::default();
        let mut temp_mem = TempMemBase::default();

        InstrEmiter::new(&mut instrs, &mut modules, &interner, &mut diagnostics)
            .emmit(&mut temp_mem);

        if !diagnostics.diagnostic_view().is_empty() {
            ctx.push_str("emmiter diagnostics:\n");
            ctx.push_str(diagnostics.diagnostic_view());
        }

        ctx.push_str("instrs:\n");
        for module in modules.changed() {
            let module_name = modules.name_of(module);
            let instr_module = &instrs.modules[module];
            ctx.push_str("  ");
            ctx.push_str(&interner[module_name]);
            ctx.push_str(":\n");

            let meta_view = instrs.module_meta.view(instr_module.meta);
            for item in meta_view.items {
                ctx.push_str("    ");
                ctx.push_str(&interner[item.name]);

                match item.kind {
                    InstrItemKind::Func(func) => {
                        ctx.push_str(":\n");
                        let func = &meta_view.funcs[func];
                        let func_meta_view = instrs.func_meta.view(func.meta);
                        format_instrs(func_meta_view.instrs, ctx, "      ", &interner);
                    }
                    InstrItemKind::Import(module) => {
                        ctx.push_str(": :{");
                        ctx.push_str(&interner[modules.name_of(module)]);
                        ctx.push_str("}\n");
                    }
                }
            }
        }
    }

    macro_rules! cases {
        ($(
            $name:ident $sources:literal
        )*) => {print_test::cases! {$(
            fn $name(ctx) {
                perform_test($sources, ctx);
            }
        )*}};
    }

    cases! {
        single_module "`root
            main: || foo(1, 1);
            foo: |a, b| a + b + 1;
        `"

        multy_module "
            `root
                main: || :{a}.foo(1, 1);
            `

            `a
                foo: |a, b| a + b + 1;
            `
        "
        variables "`root
            main: || {
                a: 1;
                b: 2;
                c: a + b;
                c
            };
        `"
        variables_in_scopes "`root
            main: || {
                a: 1;
                b: 2;
                c: {
                    a: 2;
                    b: 3;
                    a + b
                };
                c + a + b
            };
        `"
        control_flow "`root
            fib: |x| {
                if x < 2 {
                    x
                } else {
                    fib(x - 1) + fib(x - 2)
                }
            };

            iter_fib: |x| {
                a: 0;
                b: 1;
                loop if x == 0 break else {
                    c: a + b;
                    a = b;
                    b = c;
                    x -= 1;
                };
                a
            };
        `"
        imports "
            `root
                a: :{a};
                main: || a.foo(1, 1);
            `

            `a
                foo: |a, b| a + b + 1;
            `
        "
    }
}
